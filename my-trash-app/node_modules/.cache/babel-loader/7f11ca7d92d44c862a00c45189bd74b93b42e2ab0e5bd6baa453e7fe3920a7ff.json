{"ast":null,"code":"import { ulebEncode } from \"./uleb.js\";\nimport { encodeStr } from \"./utils.js\";\nclass BcsWriter {\n  constructor({\n    initialSize = 1024,\n    maxSize = Infinity,\n    allocateSize = 1024\n  } = {}) {\n    this.bytePosition = 0;\n    this.size = initialSize;\n    this.maxSize = maxSize;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(initialSize));\n  }\n  ensureSizeOrGrow(bytes) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, Math.max(this.size + requiredSize, this.size + this.allocateSize));\n      if (requiredSize > nextSize) {\n        throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);\n      }\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value) {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeBytes(bytes) {\n    this.ensureSizeOrGrow(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n      this.dataView.setUint8(this.bytePosition + i, bytes[i]);\n    }\n    return this.shift(bytes.length);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value) {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value) {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value) {\n    toLittleEndian(BigInt(value), 8).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value) {\n    toLittleEndian(BigInt(value), 16).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value) {\n    toLittleEndian(BigInt(value), 32).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value) {\n    ulebEncode(value).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(vector, cb) {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  // oxlint-disable-next-line require-yields\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes() {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding) {\n    return encodeStr(this.toBytes(), encoding);\n  }\n}\nfunction toLittleEndian(bigint, size) {\n  const result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\nexport { BcsWriter };","map":{"version":3,"names":["ulebEncode","encodeStr","BcsWriter","constructor","initialSize","maxSize","Infinity","allocateSize","bytePosition","size","dataView","DataView","ArrayBuffer","ensureSizeOrGrow","bytes","requiredSize","nextSize","Math","min","max","Error","nextBuffer","Uint8Array","set","buffer","shift","write8","value","setUint8","Number","writeBytes","length","i","write16","setUint16","write32","setUint32","write64","toLittleEndian","BigInt","forEach","el","write128","write256","writeULEB","writeVec","vector","cb","Array","from","Symbol","iterator","getUint8","toBytes","slice","toString","encoding","bigint","result"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/bcs/src/writer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView<ArrayBuffer>;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(\n\t\t\t\tthis.maxSize,\n\t\t\t\tMath.max(this.size + requiredSize, this.size + this.allocateSize),\n\t\t\t);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteBytes(bytes: Uint8Array): this {\n\t\tthis.ensureSizeOrGrow(bytes.length);\n\n\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\tthis.dataView.setUint8(this.bytePosition + i, bytes[i]);\n\t\t}\n\n\t\treturn this.shift(bytes.length);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t// oxlint-disable-next-line require-yields\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array<ArrayBuffer> {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tconst result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}