{"ast":null,"code":"import { toBase58 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { TransactionDataSchema } from \"./data/internal.js\";\nimport { transactionDataFromV1 } from \"./data/v1.js\";\nimport { hashTypedData } from \"./hash.js\";\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nclass TransactionDataBuilder {\n  constructor(clone) {\n    this.version = 2;\n    this.sender = clone?.sender ?? null;\n    this.expiration = clone?.expiration ?? null;\n    this.inputs = clone?.inputs ?? [];\n    this.commands = clone?.commands ?? [];\n    this.gasData = clone?.gasData ?? {\n      budget: null,\n      price: null,\n      owner: null,\n      payment: null\n    };\n  }\n  static fromKindBytes(bytes) {\n    const kind = bcs.TransactionKind.parse(bytes);\n    const programmableTx = kind.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: null,\n      expiration: null,\n      gasData: {\n        budget: null,\n        owner: null,\n        payment: null,\n        price: null\n      },\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static fromBytes(bytes) {\n    const rawData = bcs.TransactionData.parse(bytes);\n    const data = rawData?.V1;\n    const programmableTx = data.kind.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasData: data.gasData,\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static restore(data) {\n    if (data.version === 2) {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, data));\n    } else {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n    }\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toBase58(hash);\n  }\n  // @deprecated use gasData instead\n  get gasConfig() {\n    return this.gasData;\n  }\n  // @deprecated use gasData instead\n  set gasConfig(value) {\n    this.gasData = value;\n  }\n  build({\n    maxSizeBytes = Infinity,\n    overrides,\n    onlyTransactionKind\n  } = {}) {\n    const inputs = this.inputs;\n    const commands = this.commands;\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        commands\n      }\n    };\n    if (onlyTransactionKind) {\n      return bcs.TransactionKind.serialize(kind, {\n        maxSize: maxSizeBytes\n      }).toBytes();\n    }\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasData = {\n      ...this.gasData,\n      ...overrides?.gasConfig,\n      ...overrides?.gasData\n    };\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasData.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasData.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasData.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : {\n        None: true\n      },\n      gasData: {\n        payment: gasData.payment,\n        owner: prepareSuiAddress(this.gasData.owner ?? sender),\n        price: BigInt(gasData.price),\n        budget: BigInt(gasData.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          commands\n        }\n      }\n    };\n    return bcs.TransactionData.serialize({\n      V1: transactionData\n    }, {\n      maxSize: maxSizeBytes\n    }).toBytes();\n  }\n  addInput(type, arg) {\n    const index = this.inputs.length;\n    this.inputs.push(arg);\n    return {\n      Input: index,\n      type,\n      $kind: \"Input\"\n    };\n  }\n  getInputUses(index, fn) {\n    this.mapArguments((arg, command) => {\n      if (arg.$kind === \"Input\" && arg.Input === index) {\n        fn(arg, command);\n      }\n      return arg;\n    });\n  }\n  mapCommandArguments(index, fn) {\n    const command = this.commands[index];\n    switch (command.$kind) {\n      case \"MoveCall\":\n        command.MoveCall.arguments = command.MoveCall.arguments.map(arg => fn(arg, command, index));\n        break;\n      case \"TransferObjects\":\n        command.TransferObjects.objects = command.TransferObjects.objects.map(arg => fn(arg, command, index));\n        command.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n        break;\n      case \"SplitCoins\":\n        command.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n        command.SplitCoins.amounts = command.SplitCoins.amounts.map(arg => fn(arg, command, index));\n        break;\n      case \"MergeCoins\":\n        command.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n        command.MergeCoins.sources = command.MergeCoins.sources.map(arg => fn(arg, command, index));\n        break;\n      case \"MakeMoveVec\":\n        command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(arg => fn(arg, command, index));\n        break;\n      case \"Upgrade\":\n        command.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n        break;\n      case \"$Intent\":\n        const inputs = command.$Intent.inputs;\n        command.$Intent.inputs = {};\n        for (const [key, value] of Object.entries(inputs)) {\n          command.$Intent.inputs[key] = Array.isArray(value) ? value.map(arg => fn(arg, command, index)) : fn(value, command, index);\n        }\n        break;\n      case \"Publish\":\n        break;\n      default:\n        throw new Error(`Unexpected transaction kind: ${command.$kind}`);\n    }\n  }\n  mapArguments(fn) {\n    for (const commandIndex of this.commands.keys()) {\n      this.mapCommandArguments(commandIndex, fn);\n    }\n  }\n  replaceCommand(index, replacement, resultIndex = index) {\n    if (!Array.isArray(replacement)) {\n      this.commands[index] = replacement;\n      return;\n    }\n    const sizeDiff = replacement.length - 1;\n    this.commands.splice(index, 1, ...replacement);\n    if (sizeDiff !== 0) {\n      this.mapArguments((arg, _command, commandIndex) => {\n        if (commandIndex < index + replacement.length) {\n          return arg;\n        }\n        switch (arg.$kind) {\n          case \"Result\":\n            if (arg.Result === index) {\n              arg.Result = resultIndex;\n            }\n            if (arg.Result > index) {\n              arg.Result += sizeDiff;\n            }\n            break;\n          case \"NestedResult\":\n            if (arg.NestedResult[0] === index) {\n              arg.NestedResult[0] = resultIndex;\n            }\n            if (arg.NestedResult[0] > index) {\n              arg.NestedResult[0] += sizeDiff;\n            }\n            break;\n        }\n        return arg;\n      });\n    }\n  }\n  getDigest() {\n    const bytes = this.build({\n      onlyTransactionKind: false\n    });\n    return TransactionDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return parse(TransactionDataSchema, this);\n  }\n  shallowClone() {\n    return new TransactionDataBuilder({\n      version: this.version,\n      sender: this.sender,\n      expiration: this.expiration,\n      gasData: {\n        ...this.gasData\n      },\n      inputs: [...this.inputs],\n      commands: [...this.commands]\n    });\n  }\n  applyResolvedData(resolved) {\n    if (!this.sender) {\n      this.sender = resolved.sender ?? null;\n    }\n    if (!this.expiration) {\n      this.expiration = resolved.expiration ?? null;\n    }\n    if (!this.gasData.budget) {\n      this.gasData.budget = resolved.gasData.budget;\n    }\n    if (!this.gasData.owner) {\n      this.gasData.owner = resolved.gasData.owner ?? null;\n    }\n    if (!this.gasData.payment) {\n      this.gasData.payment = resolved.gasData.payment;\n    }\n    if (!this.gasData.price) {\n      this.gasData.price = resolved.gasData.price;\n    }\n    for (let i = 0; i < this.inputs.length; i++) {\n      const input = this.inputs[i];\n      const resolvedInput = resolved.inputs[i];\n      switch (input.$kind) {\n        case \"UnresolvedPure\":\n          if (resolvedInput.$kind !== \"Pure\") {\n            throw new Error(`Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(resolvedInput)}`);\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n        case \"UnresolvedObject\":\n          if (resolvedInput.$kind !== \"Object\") {\n            throw new Error(`Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(resolvedInput)}`);\n          }\n          if (resolvedInput.Object.$kind === \"ImmOrOwnedObject\" || resolvedInput.Object.$kind === \"Receiving\") {\n            const original = input.UnresolvedObject;\n            const resolved2 = resolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.version != null && original.version !== resolved2.version || original.digest != null && original.digest !== resolved2.digest ||\n            // Objects with shared object properties should not resolve to owned objects\n            original.mutable != null || original.initialSharedVersion != null) {\n              throw new Error(`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`);\n            }\n          } else if (resolvedInput.Object.$kind === \"SharedObject\") {\n            const original = input.UnresolvedObject;\n            const resolved2 = resolvedInput.Object.SharedObject;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.initialSharedVersion != null && original.initialSharedVersion !== resolved2.initialSharedVersion || original.mutable != null && original.mutable !== resolved2.mutable ||\n            // Objects with owned object properties should not resolve to shared objects\n            original.version != null || original.digest != null) {\n              throw new Error(`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`);\n            }\n          } else {\n            throw new Error(`Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(resolvedInput.Object)}`);\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n      }\n    }\n  }\n}\nexport { TransactionDataBuilder };","map":{"version":3,"names":["toBase58","parse","bcs","normalizeSuiAddress","TransactionDataSchema","transactionDataFromV1","hashTypedData","prepareSuiAddress","address","replace","TransactionDataBuilder","constructor","clone","version","sender","expiration","inputs","commands","gasData","budget","price","owner","payment","fromKindBytes","bytes","kind","TransactionKind","programmableTx","ProgrammableTransaction","Error","restore","fromBytes","rawData","TransactionData","data","V1","getDigestFromBytes","hash","gasConfig","value","build","maxSizeBytes","Infinity","overrides","onlyTransactionKind","serialize","maxSize","toBytes","transactionData","None","BigInt","addInput","type","arg","index","length","push","Input","$kind","getInputUses","fn","mapArguments","command","mapCommandArguments","MoveCall","arguments","map","TransferObjects","objects","SplitCoins","coin","amounts","MergeCoins","destination","sources","MakeMoveVec","elements","Upgrade","ticket","$Intent","key","Object","entries","Array","isArray","commandIndex","keys","replaceCommand","replacement","resultIndex","sizeDiff","splice","_command","Result","NestedResult","getDigest","snapshot","shallowClone","applyResolvedData","resolved","i","input","resolvedInput","JSON","stringify","original","UnresolvedObject","resolved2","ImmOrOwnedObject","Receiving","objectId","digest","mutable","initialSharedVersion","SharedObject"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/sui/src/transactions/TransactionData.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type {\n\tArgument,\n\tCallArg,\n\tCommand,\n\tGasData,\n\tTransactionExpiration,\n\tTransactionData,\n} from './data/internal.js';\nimport { TransactionDataSchema } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\n\t\tconst programmableTx = kind.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: null,\n\t\t\texpiration: null,\n\t\t\tgasData: {\n\t\t\t\tbudget: null,\n\t\t\t\towner: null,\n\t\t\t\tpayment: null,\n\t\t\t\tprice: null,\n\t\t\t},\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data.kind.ProgrammableTransaction;\n\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: data.sender,\n\t\t\texpiration: data.expiration,\n\t\t\tgasData: data.gasData,\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic restore(\n\t\tdata:\n\t\t\t| InferInput<typeof SerializedTransactionDataV2Schema>\n\t\t\t| InferInput<typeof SerializedTransactionDataV1>,\n\t) {\n\t\tif (data.version === 2) {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, data));\n\t\t} else {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n\t\t}\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toBase58(hash);\n\t}\n\n\t// @deprecated use gasData instead\n\tget gasConfig() {\n\t\treturn this.gasData;\n\t}\n\t// @deprecated use gasData instead\n\tset gasConfig(value) {\n\t\tthis.gasData = value;\n\t}\n\n\tversion = 2 as const;\n\tsender: string | null;\n\texpiration: TransactionExpiration | null;\n\tgasData: GasData;\n\tinputs: CallArg[];\n\tcommands: Command[];\n\n\tconstructor(clone?: TransactionData) {\n\t\tthis.sender = clone?.sender ?? null;\n\t\tthis.expiration = clone?.expiration ?? null;\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.commands = clone?.commands ?? [];\n\t\tthis.gasData = clone?.gasData ?? {\n\t\t\tbudget: null,\n\t\t\tprice: null,\n\t\t\towner: null,\n\t\t\tpayment: null,\n\t\t};\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: {\n\t\t\texpiration?: TransactionExpiration;\n\t\t\tsender?: string;\n\t\t\t// @deprecated use gasData instead\n\t\t\tgasConfig?: Partial<GasData>;\n\t\t\tgasData?: Partial<GasData>;\n\t\t};\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// TODO validate that inputs and intents are actually resolved\n\t\tconst inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n\t\tconst commands = this.commands as Extract<\n\t\t\tCommand<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n\t\t\t{ Upgrade: unknown }\n\t\t>[];\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasData.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasData.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasData.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasData.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasData.owner ?? sender),\n\t\t\t\tprice: BigInt(gasData.price),\n\t\t\t\tbudget: BigInt(gasData.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\tcommands,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\taddInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n\t\tconst index = this.inputs.length;\n\t\tthis.inputs.push(arg);\n\t\treturn { Input: index, type, $kind: 'Input' as const };\n\t}\n\n\tgetInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n\t\tthis.mapArguments((arg, command) => {\n\t\t\tif (arg.$kind === 'Input' && arg.Input === index) {\n\t\t\t\tfn(arg, command);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\tmapCommandArguments(\n\t\tindex: number,\n\t\tfn: (arg: Argument, command: Command, commandIndex: number) => Argument,\n\t) {\n\t\tconst command = this.commands[index];\n\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MoveCall':\n\t\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tcommand.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n\t\t\t\tbreak;\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n\t\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MergeCoins':\n\t\t\t\tcommand.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n\t\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'Upgrade':\n\t\t\t\tcommand.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n\t\t\t\tbreak;\n\t\t\tcase '$Intent':\n\t\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value)\n\t\t\t\t\t\t? value.map((arg) => fn(arg, command, index))\n\t\t\t\t\t\t: fn(value, command, index);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'Publish':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`);\n\t\t}\n\t}\n\n\tmapArguments(fn: (arg: Argument, command: Command, commandIndex: number) => Argument) {\n\t\tfor (const commandIndex of this.commands.keys()) {\n\t\t\tthis.mapCommandArguments(commandIndex, fn);\n\t\t}\n\t}\n\n\treplaceCommand(index: number, replacement: Command | Command[], resultIndex = index) {\n\t\tif (!Array.isArray(replacement)) {\n\t\t\tthis.commands[index] = replacement;\n\t\t\treturn;\n\t\t}\n\n\t\tconst sizeDiff = replacement.length - 1;\n\t\tthis.commands.splice(index, 1, ...replacement);\n\n\t\tif (sizeDiff !== 0) {\n\t\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\t\tif (commandIndex < index + replacement.length) {\n\t\t\t\t\treturn arg;\n\t\t\t\t}\n\n\t\t\t\tswitch (arg.$kind) {\n\t\t\t\t\tcase 'Result':\n\t\t\t\t\t\tif (arg.Result === index) {\n\t\t\t\t\t\t\targ.Result = resultIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (arg.Result > index) {\n\t\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NestedResult':\n\t\t\t\t\t\tif (arg.NestedResult[0] === index) {\n\t\t\t\t\t\t\targ.NestedResult[0] = resultIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (arg.NestedResult[0] > index) {\n\t\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t}\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): TransactionData {\n\t\treturn parse(TransactionDataSchema, this);\n\t}\n\n\tshallowClone() {\n\t\treturn new TransactionDataBuilder({\n\t\t\tversion: this.version,\n\t\t\tsender: this.sender,\n\t\t\texpiration: this.expiration,\n\t\t\tgasData: {\n\t\t\t\t...this.gasData,\n\t\t\t},\n\t\t\tinputs: [...this.inputs],\n\t\t\tcommands: [...this.commands],\n\t\t});\n\t}\n\n\tapplyResolvedData(resolved: TransactionData) {\n\t\tif (!this.sender) {\n\t\t\tthis.sender = resolved.sender ?? null;\n\t\t}\n\n\t\tif (!this.expiration) {\n\t\t\tthis.expiration = resolved.expiration ?? null;\n\t\t}\n\n\t\tif (!this.gasData.budget) {\n\t\t\tthis.gasData.budget = resolved.gasData.budget;\n\t\t}\n\n\t\tif (!this.gasData.owner) {\n\t\t\tthis.gasData.owner = resolved.gasData.owner ?? null;\n\t\t}\n\n\t\tif (!this.gasData.payment) {\n\t\t\tthis.gasData.payment = resolved.gasData.payment;\n\t\t}\n\n\t\tif (!this.gasData.price) {\n\t\t\tthis.gasData.price = resolved.gasData.price;\n\t\t}\n\n\t\tfor (let i = 0; i < this.inputs.length; i++) {\n\t\t\tconst input = this.inputs[i];\n\t\t\tconst resolvedInput = resolved.inputs[i];\n\n\t\t\tswitch (input.$kind) {\n\t\t\t\tcase 'UnresolvedPure':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Pure') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UnresolvedObject':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Object') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'ImmOrOwnedObject' ||\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'Receiving'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved =\n\t\t\t\t\t\t\tresolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving!;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.version != null && original.version !== resolved.version) ||\n\t\t\t\t\t\t\t(original.digest != null && original.digest !== resolved.digest) ||\n\t\t\t\t\t\t\t// Objects with shared object properties should not resolve to owned objects\n\t\t\t\t\t\t\toriginal.mutable != null ||\n\t\t\t\t\t\t\toriginal.initialSharedVersion != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (resolvedInput.Object.$kind === 'SharedObject') {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved = resolvedInput.Object.SharedObject;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.initialSharedVersion != null &&\n\t\t\t\t\t\t\t\toriginal.initialSharedVersion !== resolved.initialSharedVersion) ||\n\t\t\t\t\t\t\t(original.mutable != null && original.mutable !== resolved.mutable) ||\n\t\t\t\t\t\t\t// Objects with owned object properties should not resolve to shared objects\n\t\t\t\t\t\t\toriginal.version != null ||\n\t\t\t\t\t\t\toriginal.digest != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput.Object,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}