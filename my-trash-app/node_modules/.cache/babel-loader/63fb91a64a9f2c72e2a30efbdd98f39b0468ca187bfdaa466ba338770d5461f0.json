{"ast":null,"code":"import { bigint, object, parse, string } from \"valibot\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { normalizeStructTag } from \"../../utils/sui-types.js\";\nimport { Commands } from \"../Commands.js\";\nimport { Inputs } from \"../Inputs.js\";\nimport { getClient } from \"../resolve.js\";\nconst COIN_WITH_BALANCE = \"CoinWithBalance\";\nconst SUI_TYPE = normalizeStructTag(\"0x2::sui::SUI\");\nfunction coinWithBalance({\n  type = SUI_TYPE,\n  balance,\n  useGasCoin = true\n}) {\n  let coinResult = null;\n  return tx => {\n    if (coinResult) {\n      return coinResult;\n    }\n    tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n    const coinType = type === \"gas\" ? type : normalizeStructTag(type);\n    coinResult = tx.add(Commands.Intent({\n      name: COIN_WITH_BALANCE,\n      inputs: {},\n      data: {\n        type: coinType === SUI_TYPE && useGasCoin ? \"gas\" : coinType,\n        balance: BigInt(balance)\n      }\n    }));\n    return coinResult;\n  };\n}\nconst CoinWithBalanceData = object({\n  type: string(),\n  balance: bigint()\n});\nasync function resolveCoinBalance(transactionData, buildOptions, next) {\n  const coinTypes = /* @__PURE__ */new Set();\n  const totalByType = /* @__PURE__ */new Map();\n  if (!transactionData.sender) {\n    throw new Error(\"Sender must be set to resolve CoinWithBalance\");\n  }\n  for (const command of transactionData.commands) {\n    if (command.$kind === \"$Intent\" && command.$Intent.name === COIN_WITH_BALANCE) {\n      const {\n        type,\n        balance\n      } = parse(CoinWithBalanceData, command.$Intent.data);\n      if (type !== \"gas\" && balance > 0n) {\n        coinTypes.add(type);\n      }\n      totalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n    }\n  }\n  const usedIds = /* @__PURE__ */new Set();\n  for (const input of transactionData.inputs) {\n    if (input.Object?.ImmOrOwnedObject) {\n      usedIds.add(input.Object.ImmOrOwnedObject.objectId);\n    }\n    if (input.UnresolvedObject?.objectId) {\n      usedIds.add(input.UnresolvedObject.objectId);\n    }\n  }\n  const coinsByType = /* @__PURE__ */new Map();\n  const client = getSuiClient(buildOptions);\n  await Promise.all([...coinTypes].map(async coinType => {\n    coinsByType.set(coinType, await getCoinsOfType({\n      coinType,\n      balance: totalByType.get(coinType),\n      client,\n      owner: transactionData.sender,\n      usedIds\n    }));\n  }));\n  const mergedCoins = /* @__PURE__ */new Map();\n  mergedCoins.set(\"gas\", {\n    $kind: \"GasCoin\",\n    GasCoin: true\n  });\n  for (const [index, transaction] of transactionData.commands.entries()) {\n    if (transaction.$kind !== \"$Intent\" || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n      continue;\n    }\n    const {\n      type,\n      balance\n    } = transaction.$Intent.data;\n    if (balance === 0n && type !== \"gas\") {\n      transactionData.replaceCommand(index, Commands.MoveCall({\n        target: \"0x2::coin::zero\",\n        typeArguments: [type]\n      }));\n      continue;\n    }\n    const commands = [];\n    if (!mergedCoins.has(type)) {\n      const [first, ...rest] = coinsByType.get(type).map(coin => transactionData.addInput(\"object\", Inputs.ObjectRef({\n        objectId: coin.coinObjectId,\n        digest: coin.digest,\n        version: coin.version\n      })));\n      if (rest.length > 0) {\n        commands.push(Commands.MergeCoins(first, rest));\n      }\n      mergedCoins.set(type, first);\n    }\n    commands.push(Commands.SplitCoins(mergedCoins.get(type), [transactionData.addInput(\"pure\", Inputs.Pure(bcs.u64().serialize(balance)))]));\n    transactionData.replaceCommand(index, commands);\n    transactionData.mapArguments(arg => {\n      if (arg.$kind === \"Result\" && arg.Result === index) {\n        return {\n          $kind: \"NestedResult\",\n          NestedResult: [index + commands.length - 1, 0]\n        };\n      }\n      return arg;\n    });\n  }\n  return next();\n}\nasync function getCoinsOfType({\n  coinType,\n  balance,\n  client,\n  owner,\n  usedIds\n}) {\n  let remainingBalance = balance;\n  const coins = [];\n  return loadMoreCoins();\n  async function loadMoreCoins(cursor = null) {\n    const {\n      data,\n      hasNextPage,\n      nextCursor\n    } = await client.getCoins({\n      owner,\n      coinType,\n      cursor\n    });\n    const sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n    for (const coin of sortedCoins) {\n      if (usedIds.has(coin.coinObjectId)) {\n        continue;\n      }\n      const coinBalance = BigInt(coin.balance);\n      coins.push(coin);\n      remainingBalance -= coinBalance;\n      if (remainingBalance <= 0) {\n        return coins;\n      }\n    }\n    if (hasNextPage) {\n      return loadMoreCoins(nextCursor);\n    }\n    throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n  }\n}\nfunction getSuiClient(options) {\n  const client = getClient(options);\n  if (!client.jsonRpc) {\n    throw new Error(`CoinWithBalance intent currently only works with SuiClient`);\n  }\n  return client;\n}\nexport { coinWithBalance, getSuiClient };","map":{"version":3,"names":["bigint","object","parse","string","bcs","normalizeStructTag","Commands","Inputs","getClient","COIN_WITH_BALANCE","SUI_TYPE","coinWithBalance","type","balance","useGasCoin","coinResult","tx","addIntentResolver","resolveCoinBalance","coinType","add","Intent","name","inputs","data","BigInt","CoinWithBalanceData","transactionData","buildOptions","next","coinTypes","Set","totalByType","Map","sender","Error","command","commands","$kind","$Intent","set","get","usedIds","input","Object","ImmOrOwnedObject","objectId","UnresolvedObject","coinsByType","client","getSuiClient","Promise","all","map","getCoinsOfType","owner","mergedCoins","GasCoin","index","transaction","entries","replaceCommand","MoveCall","target","typeArguments","has","first","rest","coin","addInput","ObjectRef","coinObjectId","digest","version","length","push","MergeCoins","SplitCoins","Pure","u64","serialize","mapArguments","arg","Result","NestedResult","remainingBalance","coins","loadMoreCoins","cursor","hasNextPage","nextCursor","getCoins","sortedCoins","sort","a","b","Number","coinBalance","options","jsonRpc"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/sui/src/transactions/intents/CoinWithBalance.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferInput } from 'valibot';\nimport { bigint, object, parse, string } from 'valibot';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { CoinStruct, SuiClient } from '../../client/index.js';\nimport { normalizeStructTag } from '../../utils/sui-types.js';\nimport { Commands } from '../Commands.js';\nimport type { Argument } from '../data/internal.js';\nimport { Inputs } from '../Inputs.js';\nimport { getClient } from '../resolve.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { Transaction, TransactionResult } from '../Transaction.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\n\nconst COIN_WITH_BALANCE = 'CoinWithBalance';\nconst SUI_TYPE = normalizeStructTag('0x2::sui::SUI');\n\nexport function coinWithBalance({\n\ttype = SUI_TYPE,\n\tbalance,\n\tuseGasCoin = true,\n}: {\n\tbalance: bigint | number;\n\ttype?: string;\n\tuseGasCoin?: boolean;\n}): (tx: Transaction) => TransactionResult {\n\tlet coinResult: TransactionResult | null = null;\n\n\treturn (tx: Transaction) => {\n\t\tif (coinResult) {\n\t\t\treturn coinResult;\n\t\t}\n\n\t\ttx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n\t\tconst coinType = type === 'gas' ? type : normalizeStructTag(type);\n\n\t\tcoinResult = tx.add(\n\t\t\tCommands.Intent({\n\t\t\t\tname: COIN_WITH_BALANCE,\n\t\t\t\tinputs: {},\n\t\t\t\tdata: {\n\t\t\t\t\ttype: coinType === SUI_TYPE && useGasCoin ? 'gas' : coinType,\n\t\t\t\t\tbalance: BigInt(balance),\n\t\t\t\t} satisfies InferInput<typeof CoinWithBalanceData>,\n\t\t\t}),\n\t\t);\n\n\t\treturn coinResult;\n\t};\n}\n\nconst CoinWithBalanceData = object({\n\ttype: string(),\n\tbalance: bigint(),\n});\n\nasync function resolveCoinBalance(\n\ttransactionData: TransactionDataBuilder,\n\tbuildOptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tconst coinTypes = new Set<string>();\n\tconst totalByType = new Map<string, bigint>();\n\n\tif (!transactionData.sender) {\n\t\tthrow new Error('Sender must be set to resolve CoinWithBalance');\n\t}\n\n\tfor (const command of transactionData.commands) {\n\t\tif (command.$kind === '$Intent' && command.$Intent.name === COIN_WITH_BALANCE) {\n\t\t\tconst { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);\n\n\t\t\tif (type !== 'gas' && balance > 0n) {\n\t\t\t\tcoinTypes.add(type);\n\t\t\t}\n\n\t\t\ttotalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n\t\t}\n\t}\n\tconst usedIds = new Set<string>();\n\n\tfor (const input of transactionData.inputs) {\n\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\tusedIds.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\t\tif (input.UnresolvedObject?.objectId) {\n\t\t\tusedIds.add(input.UnresolvedObject.objectId);\n\t\t}\n\t}\n\n\tconst coinsByType = new Map<string, CoinStruct[]>();\n\tconst client = getSuiClient(buildOptions);\n\tawait Promise.all(\n\t\t[...coinTypes].map(async (coinType) => {\n\t\t\tcoinsByType.set(\n\t\t\t\tcoinType,\n\t\t\t\tawait getCoinsOfType({\n\t\t\t\t\tcoinType,\n\t\t\t\t\tbalance: totalByType.get(coinType)!,\n\t\t\t\t\tclient,\n\t\t\t\t\towner: transactionData.sender!,\n\t\t\t\t\tusedIds,\n\t\t\t\t}),\n\t\t\t);\n\t\t}),\n\t);\n\n\tconst mergedCoins = new Map<string, Argument>();\n\n\tmergedCoins.set('gas', { $kind: 'GasCoin', GasCoin: true });\n\n\tfor (const [index, transaction] of transactionData.commands.entries()) {\n\t\tif (transaction.$kind !== '$Intent' || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { type, balance } = transaction.$Intent.data as {\n\t\t\ttype: string;\n\t\t\tbalance: bigint;\n\t\t};\n\n\t\tif (balance === 0n && type !== 'gas') {\n\t\t\ttransactionData.replaceCommand(\n\t\t\t\tindex,\n\t\t\t\tCommands.MoveCall({ target: '0x2::coin::zero', typeArguments: [type] }),\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst commands = [];\n\n\t\tif (!mergedCoins.has(type)) {\n\t\t\tconst [first, ...rest] = coinsByType.get(type)!.map((coin) =>\n\t\t\t\ttransactionData.addInput(\n\t\t\t\t\t'object',\n\t\t\t\t\tInputs.ObjectRef({\n\t\t\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\t\t\tdigest: coin.digest,\n\t\t\t\t\t\tversion: coin.version,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\n\t\t\tif (rest.length > 0) {\n\t\t\t\tcommands.push(Commands.MergeCoins(first, rest));\n\t\t\t}\n\n\t\t\tmergedCoins.set(type, first);\n\t\t}\n\n\t\tcommands.push(\n\t\t\tCommands.SplitCoins(mergedCoins.get(type)!, [\n\t\t\t\ttransactionData.addInput('pure', Inputs.Pure(bcs.u64().serialize(balance))),\n\t\t\t]),\n\t\t);\n\n\t\ttransactionData.replaceCommand(index, commands);\n\n\t\ttransactionData.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Result' && arg.Result === index) {\n\t\t\t\treturn {\n\t\t\t\t\t$kind: 'NestedResult',\n\t\t\t\t\tNestedResult: [index + commands.length - 1, 0],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\treturn next();\n}\n\nasync function getCoinsOfType({\n\tcoinType,\n\tbalance,\n\tclient,\n\towner,\n\tusedIds,\n}: {\n\tcoinType: string;\n\tbalance: bigint;\n\tclient: SuiClient;\n\towner: string;\n\tusedIds: Set<string>;\n}): Promise<CoinStruct[]> {\n\tlet remainingBalance = balance;\n\tconst coins: CoinStruct[] = [];\n\n\treturn loadMoreCoins();\n\n\tasync function loadMoreCoins(cursor: string | null = null): Promise<CoinStruct[]> {\n\t\tconst { data, hasNextPage, nextCursor } = await client.getCoins({ owner, coinType, cursor });\n\n\t\tconst sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n\n\t\tfor (const coin of sortedCoins) {\n\t\t\tif (usedIds.has(coin.coinObjectId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst coinBalance = BigInt(coin.balance);\n\n\t\t\tcoins.push(coin);\n\t\t\tremainingBalance -= coinBalance;\n\n\t\t\tif (remainingBalance <= 0) {\n\t\t\t\treturn coins;\n\t\t\t}\n\t\t}\n\n\t\tif (hasNextPage) {\n\t\t\treturn loadMoreCoins(nextCursor);\n\t\t}\n\n\t\tthrow new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n\t}\n}\n\nexport function getSuiClient(options: BuildTransactionOptions): SuiClient {\n\tconst client = getClient(options) as SuiClient;\n\tif (!client.jsonRpc) {\n\t\tthrow new Error(`CoinWithBalance intent currently only works with SuiClient`);\n\t}\n\n\treturn client;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}