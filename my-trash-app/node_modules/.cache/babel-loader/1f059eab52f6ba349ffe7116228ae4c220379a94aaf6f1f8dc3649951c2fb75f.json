{"ast":null,"code":"import { ulebDecode } from \"./uleb.js\";\nclass BcsReader {\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data) {\n    this.bytePosition = 0;\n    this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8() {\n    const value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16() {\n    const value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32() {\n    const value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64() {\n    const value1 = this.read32();\n    const value2 = this.read32();\n    const result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128() {\n    const value1 = BigInt(this.read64());\n    const value2 = BigInt(this.read64());\n    const result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256() {\n    const value1 = BigInt(this.read128());\n    const value2 = BigInt(this.read128());\n    const result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num) {\n    const start = this.bytePosition + this.dataView.byteOffset;\n    const value = new Uint8Array(this.dataView.buffer, start, num);\n    this.shift(num);\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB() {\n    const start = this.bytePosition + this.dataView.byteOffset;\n    const buffer = new Uint8Array(this.dataView.buffer, start);\n    const {\n      value,\n      length\n    } = ulebDecode(buffer);\n    this.shift(length);\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb) {\n    const length = this.readULEB();\n    const result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n}\nexport { BcsReader };","map":{"version":3,"names":["ulebDecode","BcsReader","constructor","data","bytePosition","dataView","DataView","buffer","byteOffset","byteLength","shift","bytes","read8","value","getUint8","read16","getUint16","read32","getUint32","read64","value1","value2","result","toString","padStart","BigInt","read128","read256","readBytes","num","start","Uint8Array","readULEB","length","readVec","cb","i","push"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/bcs/src/reader.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tconst value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tconst value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tconst value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tconst value1 = this.read32();\n\t\tconst value2 = this.read32();\n\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tconst value1 = BigInt(this.read64());\n\t\tconst value2 = BigInt(this.read64());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tconst value1 = BigInt(this.read128());\n\t\tconst value2 = BigInt(this.read128());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tconst { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tconst length = this.readULEB();\n\t\tconst result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n"],"mappings":"AAGA,SAASA,UAAA,QAAkB;AAgCpB,MAAMC,SAAA,CAAU;EAAA;AAAA;AAAA;EAOtBC,YAAYC,IAAA,EAAkB;IAL9B,KAAQC,YAAA,GAAuB;IAM9B,KAAKC,QAAA,GAAW,IAAIC,QAAA,CAASH,IAAA,CAAKI,MAAA,EAAQJ,IAAA,CAAKK,UAAA,EAAYL,IAAA,CAAKM,UAAU;EAC3E;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAOAC,MAAMC,KAAA,EAAe;IACpB,KAAKP,YAAA,IAAgBO,KAAA;IACrB,OAAO;EACR;EAAA;AAAA;AAAA;AAAA;EAKAC,MAAA,EAAgB;IACf,MAAMC,KAAA,GAAQ,KAAKR,QAAA,CAASS,QAAA,CAAS,KAAKV,YAAY;IACtD,KAAKM,KAAA,CAAM,CAAC;IACZ,OAAOG,KAAA;EACR;EAAA;AAAA;AAAA;AAAA;EAKAE,OAAA,EAAiB;IAChB,MAAMF,KAAA,GAAQ,KAAKR,QAAA,CAASW,SAAA,CAAU,KAAKZ,YAAA,EAAc,IAAI;IAC7D,KAAKM,KAAA,CAAM,CAAC;IACZ,OAAOG,KAAA;EACR;EAAA;AAAA;AAAA;AAAA;EAKAI,OAAA,EAAiB;IAChB,MAAMJ,KAAA,GAAQ,KAAKR,QAAA,CAASa,SAAA,CAAU,KAAKd,YAAA,EAAc,IAAI;IAC7D,KAAKM,KAAA,CAAM,CAAC;IACZ,OAAOG,KAAA;EACR;EAAA;AAAA;AAAA;AAAA;EAKAM,OAAA,EAAiB;IAChB,MAAMC,MAAA,GAAS,KAAKH,MAAA,CAAO;IAC3B,MAAMI,MAAA,GAAS,KAAKJ,MAAA,CAAO;IAE3B,MAAMK,MAAA,GAASD,MAAA,CAAOE,QAAA,CAAS,EAAE,IAAIH,MAAA,CAAOG,QAAA,CAAS,EAAE,EAAEC,QAAA,CAAS,GAAG,GAAG;IAExE,OAAOC,MAAA,CAAO,OAAOH,MAAM,EAAEC,QAAA,CAAS,EAAE;EACzC;EAAA;AAAA;AAAA;EAIAG,QAAA,EAAkB;IACjB,MAAMN,MAAA,GAASK,MAAA,CAAO,KAAKN,MAAA,CAAO,CAAC;IACnC,MAAME,MAAA,GAASI,MAAA,CAAO,KAAKN,MAAA,CAAO,CAAC;IACnC,MAAMG,MAAA,GAASD,MAAA,CAAOE,QAAA,CAAS,EAAE,IAAIH,MAAA,CAAOG,QAAA,CAAS,EAAE,EAAEC,QAAA,CAAS,IAAI,GAAG;IAEzE,OAAOC,MAAA,CAAO,OAAOH,MAAM,EAAEC,QAAA,CAAS,EAAE;EACzC;EAAA;AAAA;AAAA;AAAA;EAKAI,QAAA,EAAkB;IACjB,MAAMP,MAAA,GAASK,MAAA,CAAO,KAAKC,OAAA,CAAQ,CAAC;IACpC,MAAML,MAAA,GAASI,MAAA,CAAO,KAAKC,OAAA,CAAQ,CAAC;IACpC,MAAMJ,MAAA,GAASD,MAAA,CAAOE,QAAA,CAAS,EAAE,IAAIH,MAAA,CAAOG,QAAA,CAAS,EAAE,EAAEC,QAAA,CAAS,IAAI,GAAG;IAEzE,OAAOC,MAAA,CAAO,OAAOH,MAAM,EAAEC,QAAA,CAAS,EAAE;EACzC;EAAA;AAAA;AAAA;AAAA;EAKAK,UAAUC,GAAA,EAAyB;IAClC,MAAMC,KAAA,GAAQ,KAAK1B,YAAA,GAAe,KAAKC,QAAA,CAASG,UAAA;IAChD,MAAMK,KAAA,GAAQ,IAAIkB,UAAA,CAAW,KAAK1B,QAAA,CAASE,MAAA,EAAQuB,KAAA,EAAOD,GAAG;IAE7D,KAAKnB,KAAA,CAAMmB,GAAG;IAEd,OAAOhB,KAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;EAMAmB,SAAA,EAAmB;IAClB,MAAMF,KAAA,GAAQ,KAAK1B,YAAA,GAAe,KAAKC,QAAA,CAASG,UAAA;IAChD,MAAMD,MAAA,GAAS,IAAIwB,UAAA,CAAW,KAAK1B,QAAA,CAASE,MAAA,EAAQuB,KAAK;IACzD,MAAM;MAAEjB,KAAA;MAAOoB;IAAO,IAAIjC,UAAA,CAAWO,MAAM;IAE3C,KAAKG,KAAA,CAAMuB,MAAM;IAEjB,OAAOpB,KAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAOAqB,QAAQC,EAAA,EAAkE;IACzE,MAAMF,MAAA,GAAS,KAAKD,QAAA,CAAS;IAC7B,MAAMV,MAAA,GAAS,EAAC;IAChB,SAASc,CAAA,GAAI,GAAGA,CAAA,GAAIH,MAAA,EAAQG,CAAA,IAAK;MAChCd,MAAA,CAAOe,IAAA,CAAKF,EAAA,CAAG,MAAMC,CAAA,EAAGH,MAAM,CAAC;IAChC;IACA,OAAOX,MAAA;EACR;AACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}