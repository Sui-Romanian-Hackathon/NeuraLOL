{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _cache, _url, _pageSize, _overrides, _MvrClient_instances, mvrPackageDataLoader_get, mvrTypeDataLoader_get, resolvePackages_fn, resolveTypes_fn, fetch_fn;\nimport { chunk, DataLoader } from \"@mysten/utils\";\nimport { isValidNamedPackage, isValidNamedType } from \"../utils/move-registry.js\";\nimport { isValidSuiAddress, normalizeStructTag, normalizeSuiAddress, parseStructTag } from \"../utils/sui-types.js\";\nimport { PACKAGE_VERSION } from \"../version.js\";\nconst NAME_SEPARATOR = \"/\";\nconst MVR_API_HEADER = {\n  \"Mvr-Source\": `@mysten/sui@${PACKAGE_VERSION}`\n};\nclass MvrClient {\n  constructor({\n    cache,\n    url,\n    pageSize = 50,\n    overrides\n  }) {\n    __privateAdd(this, _MvrClient_instances);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _url);\n    __privateAdd(this, _pageSize);\n    __privateAdd(this, _overrides);\n    __privateSet(this, _cache, cache);\n    __privateSet(this, _url, url);\n    __privateSet(this, _pageSize, pageSize);\n    __privateSet(this, _overrides, {\n      packages: overrides?.packages,\n      types: overrides?.types\n    });\n    validateOverrides(__privateGet(this, _overrides));\n  }\n  async resolvePackage({\n    package: name\n  }) {\n    if (!hasMvrName(name)) {\n      return {\n        package: name\n      };\n    }\n    const resolved = await __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).load(name);\n    return {\n      package: resolved\n    };\n  }\n  async resolveType({\n    type\n  }) {\n    if (!hasMvrName(type)) {\n      return {\n        type\n      };\n    }\n    const mvrTypes = [...extractMvrTypes(type)];\n    const resolvedTypes = await __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(mvrTypes);\n    const typeMap = {};\n    for (let i = 0; i < mvrTypes.length; i++) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[mvrTypes[i]] = resolvedType;\n    }\n    return {\n      type: replaceMvrNames(type, typeMap)\n    };\n  }\n  async resolve({\n    types = [],\n    packages = []\n  }) {\n    const mvrTypes = /* @__PURE__ */new Set();\n    for (const type of types ?? []) {\n      extractMvrTypes(type, mvrTypes);\n    }\n    const typesArray = [...mvrTypes];\n    const [resolvedTypes, resolvedPackages] = await Promise.all([typesArray.length > 0 ? __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(typesArray) : [], packages.length > 0 ? __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).loadMany(packages) : []]);\n    const typeMap = {\n      ...__privateGet(this, _overrides)?.types\n    };\n    for (const [i, type] of typesArray.entries()) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[type] = resolvedType;\n    }\n    const replacedTypes = {};\n    for (const type of types ?? []) {\n      const resolvedType = replaceMvrNames(type, typeMap);\n      replacedTypes[type] = {\n        type: resolvedType\n      };\n    }\n    const replacedPackages = {};\n    for (const [i, pkg] of (packages ?? []).entries()) {\n      const resolvedPkg = __privateGet(this, _overrides)?.packages?.[pkg] ?? resolvedPackages[i];\n      if (resolvedPkg instanceof Error) {\n        throw resolvedPkg;\n      }\n      replacedPackages[pkg] = {\n        package: resolvedPkg\n      };\n    }\n    return {\n      types: replacedTypes,\n      packages: replacedPackages\n    };\n  }\n}\n_cache = new WeakMap();\n_url = new WeakMap();\n_pageSize = new WeakMap();\n_overrides = new WeakMap();\n_MvrClient_instances = new WeakSet();\nmvrPackageDataLoader_get = function () {\n  return __privateGet(this, _cache).readSync([\"#mvrPackageDataLoader\", __privateGet(this, _url) ?? \"\"], () => {\n    const loader = new DataLoader(async packages => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(`MVR Api URL is not set for the current client (resolving ${packages.join(\", \")})`);\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolvePackages_fn).call(this, packages);\n      return packages.map(pkg => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`));\n    });\n    const overrides = __privateGet(this, _overrides)?.packages;\n    if (overrides) {\n      for (const [pkg, id] of Object.entries(overrides)) {\n        loader.prime(pkg, id);\n      }\n    }\n    return loader;\n  });\n};\nmvrTypeDataLoader_get = function () {\n  return __privateGet(this, _cache).readSync([\"#mvrTypeDataLoader\", __privateGet(this, _url) ?? \"\"], () => {\n    const loader = new DataLoader(async types => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(`MVR Api URL is not set for the current client (resolving ${types.join(\", \")})`);\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolveTypes_fn).call(this, types);\n      return types.map(type => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n    });\n    const overrides = __privateGet(this, _overrides)?.types;\n    if (overrides) {\n      for (const [type, id] of Object.entries(overrides)) {\n        loader.prime(type, id);\n      }\n    }\n    return loader;\n  });\n};\nresolvePackages_fn = async function (packages) {\n  if (packages.length === 0) return {};\n  const batches = chunk(packages, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(batches.map(async batch => {\n    const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/resolution/bulk\", {\n      names: batch\n    });\n    if (!data?.resolution) return;\n    for (const pkg of Object.keys(data?.resolution)) {\n      const pkgData = data.resolution[pkg]?.package_id;\n      if (!pkgData) continue;\n      results[pkg] = pkgData;\n    }\n  }));\n  return results;\n};\nresolveTypes_fn = async function (types) {\n  if (types.length === 0) return {};\n  const batches = chunk(types, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(batches.map(async batch => {\n    const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/struct-definition/bulk\", {\n      types: batch\n    });\n    if (!data?.resolution) return;\n    for (const type of Object.keys(data?.resolution)) {\n      const typeData = data.resolution[type]?.type_tag;\n      if (!typeData) continue;\n      results[type] = typeData;\n    }\n  }));\n  return results;\n};\nfetch_fn = async function (url, body) {\n  if (!__privateGet(this, _url)) {\n    throw new Error(\"MVR Api URL is not set for the current client\");\n  }\n  const response = await fetch(`${__privateGet(this, _url)}${url}`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...MVR_API_HEADER\n    },\n    body: JSON.stringify(body)\n  });\n  if (!response.ok) {\n    const errorBody = await response.json().catch(() => ({}));\n    throw new Error(`Failed to resolve types: ${errorBody?.message}`);\n  }\n  return response.json();\n};\nfunction validateOverrides(overrides) {\n  if (overrides?.packages) {\n    for (const [pkg, id] of Object.entries(overrides.packages)) {\n      if (!isValidNamedPackage(pkg)) {\n        throw new Error(`Invalid package name: ${pkg}`);\n      }\n      if (!isValidSuiAddress(normalizeSuiAddress(id))) {\n        throw new Error(`Invalid package ID: ${id}`);\n      }\n    }\n  }\n  if (overrides?.types) {\n    for (const [type, val] of Object.entries(overrides.types)) {\n      if (parseStructTag(type).typeParams.length > 0) {\n        throw new Error(\"Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.\");\n      }\n      const parsedValue = parseStructTag(val);\n      if (!isValidSuiAddress(parsedValue.address)) {\n        throw new Error(`Invalid type: ${val}`);\n      }\n    }\n  }\n}\nfunction extractMvrTypes(type, types = /* @__PURE__ */new Set()) {\n  if (typeof type === \"string\" && !hasMvrName(type)) return types;\n  const tag = isStructTag(type) ? type : parseStructTag(type);\n  if (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n  for (const param of tag.typeParams) {\n    extractMvrTypes(param, types);\n  }\n  return types;\n}\nfunction replaceMvrNames(tag, typeCache) {\n  const type = isStructTag(tag) ? tag : parseStructTag(tag);\n  const typeTag = `${type.address}::${type.module}::${type.name}`;\n  const cacheHit = typeCache[typeTag];\n  return normalizeStructTag({\n    ...type,\n    address: cacheHit ? cacheHit.split(\"::\")[0] : type.address,\n    typeParams: type.typeParams.map(param => replaceMvrNames(param, typeCache))\n  });\n}\nfunction hasMvrName(nameOrType) {\n  return nameOrType.includes(NAME_SEPARATOR) || nameOrType.includes(\"@\") || nameOrType.includes(\".sui\");\n}\nfunction isStructTag(type) {\n  return typeof type === \"object\" && \"address\" in type && \"module\" in type && \"name\" in type && \"typeParams\" in type;\n}\nfunction findNamesInTransaction(builder) {\n  const packages = /* @__PURE__ */new Set();\n  const types = /* @__PURE__ */new Set();\n  for (const command of builder.commands) {\n    switch (command.$kind) {\n      case \"MakeMoveVec\":\n        if (command.MakeMoveVec.type) {\n          getNamesFromTypeList([command.MakeMoveVec.type]).forEach(type => {\n            types.add(type);\n          });\n        }\n        break;\n      case \"MoveCall\":\n        const moveCall = command.MoveCall;\n        const pkg = moveCall.package.split(\"::\")[0];\n        if (hasMvrName(pkg)) {\n          if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n          packages.add(pkg);\n        }\n        getNamesFromTypeList(moveCall.typeArguments ?? []).forEach(type => {\n          types.add(type);\n        });\n        break;\n      default:\n        break;\n    }\n  }\n  return {\n    packages: [...packages],\n    types: [...types]\n  };\n}\nfunction replaceNames(builder, resolved) {\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      if (!hasMvrName(command.MakeMoveVec.type)) continue;\n      if (!resolved.types[command.MakeMoveVec.type]) throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n      command.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n    }\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const nameParts = tx.package.split(\"::\");\n    const name = nameParts[0];\n    if (hasMvrName(name) && !resolved.packages[name]) throw new Error(`No address found for package: ${name}`);\n    if (hasMvrName(name)) {\n      nameParts[0] = resolved.packages[name].package;\n      tx.package = nameParts.join(\"::\");\n    }\n    const types = tx.typeArguments;\n    if (!types) continue;\n    for (let i = 0; i < types.length; i++) {\n      if (!hasMvrName(types[i])) continue;\n      if (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n      types[i] = resolved.types[types[i]].type;\n    }\n    tx.typeArguments = types;\n  }\n}\nfunction getNamesFromTypeList(types) {\n  const names = /* @__PURE__ */new Set();\n  for (const type of types) {\n    if (hasMvrName(type)) {\n      if (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n      names.add(type);\n    }\n  }\n  return names;\n}\nexport { MvrClient, extractMvrTypes, findNamesInTransaction, hasMvrName, replaceNames };","map":{"version":3,"names":["_cache","_url","_pageSize","_overrides","_MvrClient_instances","mvrPackageDataLoader_get","mvrTypeDataLoader_get","resolvePackages_fn","resolveTypes_fn","fetch_fn","chunk","DataLoader","isValidNamedPackage","isValidNamedType","isValidSuiAddress","normalizeStructTag","normalizeSuiAddress","parseStructTag","PACKAGE_VERSION","NAME_SEPARATOR","MVR_API_HEADER","MvrClient","constructor","cache","url","pageSize","overrides","__privateAdd","__privateSet","packages","types","validateOverrides","__privateGet","resolvePackage","package","name","hasMvrName","resolved","load","resolveType","type","mvrTypes","extractMvrTypes","resolvedTypes","loadMany","typeMap","i","length","resolvedType","Error","replaceMvrNames","resolve","Set","typesArray","resolvedPackages","Promise","all","entries","replacedTypes","replacedPackages","pkg","resolvedPkg","WeakMap","WeakSet","readSync","loader","join","__privateMethod","call","map","id","Object","prime","batches","results","batch","data","names","resolution","keys","pkgData","package_id","typeData","type_tag","body","response","fetch","method","headers","JSON","stringify","ok","errorBody","json","catch","message","val","typeParams","parsedValue","address","tag","isStructTag","add","module","param","typeCache","typeTag","cacheHit","split","nameOrType","includes","findNamesInTransaction","builder","command","commands","$kind","MakeMoveVec","getNamesFromTypeList","forEach","moveCall","MoveCall","typeArguments","replaceNames","tx","nameParts"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/sui/src/experimental/mvr.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { chunk, DataLoader } from '@mysten/utils';\nimport { isValidNamedPackage, isValidNamedType } from '../utils/move-registry.js';\nimport type { StructTag } from '../utils/sui-types.js';\nimport {\n\tisValidSuiAddress,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tparseStructTag,\n} from '../utils/sui-types.js';\nimport type { ClientCache } from './cache.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { PACKAGE_VERSION } from '../version.js';\nimport type { Experimental_SuiClientTypes } from './types.js';\n\nconst NAME_SEPARATOR = '/';\nconst MVR_API_HEADER = {\n\t'Mvr-Source': `@mysten/sui@${PACKAGE_VERSION}`,\n};\n\nexport interface MvrClientOptions {\n\tcache: ClientCache;\n\turl?: string;\n\tpageSize?: number;\n\toverrides?: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n}\n\nexport class MvrClient implements Experimental_SuiClientTypes.MvrMethods {\n\t#cache: ClientCache;\n\t#url?: string;\n\t#pageSize: number;\n\t#overrides: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n\n\tconstructor({ cache, url, pageSize = 50, overrides }: MvrClientOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#url = url;\n\t\tthis.#pageSize = pageSize;\n\t\tthis.#overrides = {\n\t\t\tpackages: overrides?.packages,\n\t\t\ttypes: overrides?.types,\n\t\t};\n\n\t\tvalidateOverrides(this.#overrides);\n\t}\n\n\tget #mvrPackageDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrPackageDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (packages) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${packages.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolvePackages(packages);\n\n\t\t\t\treturn packages.map(\n\t\t\t\t\t(pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`),\n\t\t\t\t);\n\t\t\t});\n\t\t\tconst overrides = this.#overrides?.packages;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [pkg, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(pkg, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tget #mvrTypeDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrTypeDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (types) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${types.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolveTypes(types);\n\n\t\t\t\treturn types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n\t\t\t});\n\n\t\t\tconst overrides = this.#overrides?.types;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [type, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(type, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tasync #resolvePackages(packages: readonly string[]) {\n\t\tif (packages.length === 0) return {};\n\n\t\tconst batches = chunk(packages, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { package_id: string }> }>(\n\t\t\t\t\t'/v1/resolution/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\tnames: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const pkg of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst pkgData = data.resolution[pkg]?.package_id;\n\n\t\t\t\t\tif (!pkgData) continue;\n\n\t\t\t\t\tresults[pkg] = pkgData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #resolveTypes(types: readonly string[]) {\n\t\tif (types.length === 0) return {};\n\n\t\tconst batches = chunk(types, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { type_tag: string }> }>(\n\t\t\t\t\t'/v1/struct-definition/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\ttypes: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const type of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst typeData = data.resolution[type]?.type_tag;\n\t\t\t\t\tif (!typeData) continue;\n\n\t\t\t\t\tresults[type] = typeData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #fetch<T>(url: string, body: Record<string, unknown>): Promise<T> {\n\t\tif (!this.#url) {\n\t\t\tthrow new Error('MVR Api URL is not set for the current client');\n\t\t}\n\n\t\tconst response = await fetch(`${this.#url}${url}`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...MVR_API_HEADER,\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorBody = await response.json().catch(() => ({}));\n\t\t\tthrow new Error(`Failed to resolve types: ${errorBody?.message}`);\n\t\t}\n\n\t\treturn response.json();\n\t}\n\n\tasync resolvePackage({\n\t\tpackage: name,\n\t}: Experimental_SuiClientTypes.MvrResolvePackageOptions): Promise<Experimental_SuiClientTypes.MvrResolvePackageResponse> {\n\t\tif (!hasMvrName(name)) {\n\t\t\treturn {\n\t\t\t\tpackage: name,\n\t\t\t};\n\t\t}\n\t\tconst resolved = await this.#mvrPackageDataLoader.load(name);\n\t\treturn {\n\t\t\tpackage: resolved,\n\t\t};\n\t}\n\n\tasync resolveType({\n\t\ttype,\n\t}: Experimental_SuiClientTypes.MvrResolveTypeOptions): Promise<Experimental_SuiClientTypes.MvrResolveTypeResponse> {\n\t\tif (!hasMvrName(type)) {\n\t\t\treturn {\n\t\t\t\ttype,\n\t\t\t};\n\t\t}\n\n\t\tconst mvrTypes = [...extractMvrTypes(type)];\n\t\tconst resolvedTypes = await this.#mvrTypeDataLoader.loadMany(mvrTypes);\n\n\t\tconst typeMap: Record<string, string> = {};\n\n\t\tfor (let i = 0; i < mvrTypes.length; i++) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[mvrTypes[i]] = resolvedType;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: replaceMvrNames(type, typeMap),\n\t\t};\n\t}\n\n\tasync resolve({\n\t\ttypes = [],\n\t\tpackages = [],\n\t}: Experimental_SuiClientTypes.MvrResolveOptions): Promise<Experimental_SuiClientTypes.MvrResolveResponse> {\n\t\tconst mvrTypes = new Set<string>();\n\n\t\tfor (const type of types ?? []) {\n\t\t\textractMvrTypes(type, mvrTypes);\n\t\t}\n\n\t\tconst typesArray = [...mvrTypes];\n\t\tconst [resolvedTypes, resolvedPackages] = await Promise.all([\n\t\t\ttypesArray.length > 0 ? this.#mvrTypeDataLoader.loadMany(typesArray) : [],\n\t\t\tpackages.length > 0 ? this.#mvrPackageDataLoader.loadMany(packages) : [],\n\t\t]);\n\n\t\tconst typeMap: Record<string, string> = {\n\t\t\t...this.#overrides?.types,\n\t\t};\n\n\t\tfor (const [i, type] of typesArray.entries()) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[type] = resolvedType;\n\t\t}\n\n\t\tconst replacedTypes: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const type of types ?? []) {\n\t\t\tconst resolvedType = replaceMvrNames(type, typeMap);\n\n\t\t\treplacedTypes[type] = {\n\t\t\t\ttype: resolvedType,\n\t\t\t};\n\t\t}\n\n\t\tconst replacedPackages: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpackage: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const [i, pkg] of (packages ?? []).entries()) {\n\t\t\tconst resolvedPkg = this.#overrides?.packages?.[pkg] ?? resolvedPackages[i];\n\n\t\t\tif (resolvedPkg instanceof Error) {\n\t\t\t\tthrow resolvedPkg;\n\t\t\t}\n\n\t\t\treplacedPackages[pkg] = {\n\t\t\t\tpackage: resolvedPkg,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttypes: replacedTypes,\n\t\t\tpackages: replacedPackages,\n\t\t};\n\t}\n}\n\nfunction validateOverrides(overrides?: {\n\tpackages?: Record<string, string>;\n\ttypes?: Record<string, string>;\n}) {\n\tif (overrides?.packages) {\n\t\tfor (const [pkg, id] of Object.entries(overrides.packages)) {\n\t\t\tif (!isValidNamedPackage(pkg)) {\n\t\t\t\tthrow new Error(`Invalid package name: ${pkg}`);\n\t\t\t}\n\t\t\tif (!isValidSuiAddress(normalizeSuiAddress(id))) {\n\t\t\t\tthrow new Error(`Invalid package ID: ${id}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (overrides?.types) {\n\t\tfor (const [type, val] of Object.entries(overrides.types)) {\n\t\t\t// validate that types are first-level only.\n\t\t\tif (parseStructTag(type).typeParams.length > 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst parsedValue = parseStructTag(val);\n\n\t\t\tif (!isValidSuiAddress(parsedValue.address)) {\n\t\t\t\tthrow new Error(`Invalid type: ${val}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts all named types from a given type.\n */\nexport function extractMvrTypes(type: string | StructTag, types = new Set<string>()) {\n\tif (typeof type === 'string' && !hasMvrName(type)) return types;\n\n\tconst tag = isStructTag(type) ? type : parseStructTag(type);\n\n\tif (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n\n\tfor (const param of tag.typeParams) {\n\t\textractMvrTypes(param, types);\n\t}\n\n\treturn types;\n}\n\n/**\n * Traverses a type, and replaces any found names with their resolved equivalents,\n * based on the supplied type cache.\n */\nfunction replaceMvrNames(tag: string | StructTag, typeCache: Record<string, string>): string {\n\tconst type = isStructTag(tag) ? tag : parseStructTag(tag);\n\n\tconst typeTag = `${type.address}::${type.module}::${type.name}`;\n\tconst cacheHit = typeCache[typeTag];\n\n\treturn normalizeStructTag({\n\t\t...type,\n\t\taddress: cacheHit ? cacheHit.split('::')[0] : type.address,\n\t\ttypeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache)),\n\t});\n}\n\nexport function hasMvrName(nameOrType: string) {\n\treturn (\n\t\tnameOrType.includes(NAME_SEPARATOR) || nameOrType.includes('@') || nameOrType.includes('.sui')\n\t);\n}\n\nfunction isStructTag(type: string | StructTag): type is StructTag {\n\treturn (\n\t\ttypeof type === 'object' &&\n\t\t'address' in type &&\n\t\t'module' in type &&\n\t\t'name' in type &&\n\t\t'typeParams' in type\n\t);\n}\n\nexport type NamedPackagesOverrides = {\n\tpackages: Record<string, string>;\n\ttypes: Record<string, string>;\n};\n\n/**\n * Looks up all `.move` names in a transaction block.\n * Returns a list of all the names found.\n */\nexport function findNamesInTransaction(builder: TransactionDataBuilder): {\n\tpackages: string[];\n\ttypes: string[];\n} {\n\tconst packages: Set<string> = new Set();\n\tconst types: Set<string> = new Set();\n\n\tfor (const command of builder.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tif (command.MakeMoveVec.type) {\n\t\t\t\t\tgetNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n\t\t\t\t\t\ttypes.add(type);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'MoveCall':\n\t\t\t\tconst moveCall = command.MoveCall;\n\n\t\t\t\tconst pkg = moveCall.package.split('::')[0];\n\t\t\t\tif (hasMvrName(pkg)) {\n\t\t\t\t\tif (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n\t\t\t\t\tpackages.add(pkg);\n\t\t\t\t}\n\n\t\t\t\tgetNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {\n\t\t\t\t\ttypes.add(type);\n\t\t\t\t});\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tpackages: [...packages],\n\t\ttypes: [...types],\n\t};\n}\n\n/**\n * Replace all names & types in a transaction block\n * with their resolved names/types.\n */\nexport function replaceNames(\n\tbuilder: TransactionDataBuilder,\n\tresolved: Experimental_SuiClientTypes.MvrResolveResponse,\n) {\n\tfor (const command of builder.commands) {\n\t\t// Replacements for `MakeMoveVec` commands (that can include types)\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tif (!hasMvrName(command.MakeMoveVec.type)) continue;\n\t\t\tif (!resolved.types[command.MakeMoveVec.type])\n\t\t\t\tthrow new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n\t\t\tcommand.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n\t\t}\n\t\t// Replacements for `MoveCall` commands (that can include packages & types)\n\t\tconst tx = command.MoveCall;\n\t\tif (!tx) continue;\n\n\t\tconst nameParts = tx.package.split('::');\n\t\tconst name = nameParts[0];\n\n\t\tif (hasMvrName(name) && !resolved.packages[name])\n\t\t\tthrow new Error(`No address found for package: ${name}`);\n\n\t\t// Replace package name with address.\n\t\tif (hasMvrName(name)) {\n\t\t\tnameParts[0] = resolved.packages[name].package;\n\t\t\ttx.package = nameParts.join('::');\n\t\t}\n\n\t\tconst types = tx.typeArguments;\n\t\tif (!types) continue;\n\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tif (!hasMvrName(types[i])) continue;\n\n\t\t\tif (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n\t\t\ttypes[i] = resolved.types[types[i]].type;\n\t\t}\n\n\t\ttx.typeArguments = types;\n\t}\n}\n\n/**\n * Returns a list of unique types that include a name\n * from the given list. This list is retrieved from the Transaction Data.\n */\nfunction getNamesFromTypeList(types: string[]) {\n\tconst names = new Set<string>();\n\tfor (const type of types) {\n\t\tif (hasMvrName(type)) {\n\t\t\tif (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n\t\t\tnames.add(type);\n\t\t}\n\t}\n\treturn names;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}