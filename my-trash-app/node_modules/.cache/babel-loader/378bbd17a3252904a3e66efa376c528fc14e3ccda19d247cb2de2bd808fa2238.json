{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\nvar _signer, _client, _coinBatchSize, _initialCoinBalance, _minimumCoinBalance, _epochBoundaryWindow, _defaultGasBudget, _maxPoolSize, _sourceCoins, _coinPool, _cache, _objectIdQueues, _buildQueue, _executeQueue, _lastDigest, _cacheLock, _pendingTransactions, _gasPrice, _ParallelTransactionExecutor_instances, getUsedObjects_fn, execute_fn, updateCache_fn, waitForLastDigest_fn, getGasCoin_fn, getGasPrice_fn, refillCoinPool_fn;\nimport { toBase64 } from \"@mysten/bcs\";\nimport { promiseWithResolvers } from \"@mysten/utils\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { Transaction } from \"../Transaction.js\";\nimport { TransactionDataBuilder } from \"../TransactionData.js\";\nimport { CachingTransactionExecutor } from \"./caching.js\";\nimport { ParallelQueue, SerialQueue } from \"./queue.js\";\nimport { getGasCoinFromEffects } from \"./serial.js\";\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n  coinBatchSize: 20,\n  initialCoinBalance: 200000000n,\n  minimumCoinBalance: 50000000n,\n  maxPoolSize: 50,\n  epochBoundaryWindow: 1e3\n};\nclass ParallelTransactionExecutor {\n  constructor(options) {\n    __privateAdd(this, _ParallelTransactionExecutor_instances);\n    __privateAdd(this, _signer);\n    __privateAdd(this, _client);\n    __privateAdd(this, _coinBatchSize);\n    __privateAdd(this, _initialCoinBalance);\n    __privateAdd(this, _minimumCoinBalance);\n    __privateAdd(this, _epochBoundaryWindow);\n    __privateAdd(this, _defaultGasBudget);\n    __privateAdd(this, _maxPoolSize);\n    __privateAdd(this, _sourceCoins);\n    __privateAdd(this, _coinPool, []);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _objectIdQueues, /* @__PURE__ */new Map());\n    __privateAdd(this, _buildQueue, new SerialQueue());\n    __privateAdd(this, _executeQueue);\n    __privateAdd(this, _lastDigest, null);\n    __privateAdd(this, _cacheLock, null);\n    __privateAdd(this, _pendingTransactions, 0);\n    __privateAdd(this, _gasPrice, null);\n    __privateSet(this, _signer, options.signer);\n    __privateSet(this, _client, options.client);\n    __privateSet(this, _coinBatchSize, options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize);\n    __privateSet(this, _initialCoinBalance, options.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance);\n    __privateSet(this, _minimumCoinBalance, options.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance);\n    __privateSet(this, _defaultGasBudget, options.defaultGasBudget ?? __privateGet(this, _minimumCoinBalance));\n    __privateSet(this, _epochBoundaryWindow, options.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow);\n    __privateSet(this, _maxPoolSize, options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize);\n    __privateSet(this, _cache, new CachingTransactionExecutor({\n      client: options.client,\n      cache: options.cache\n    }));\n    __privateSet(this, _executeQueue, new ParallelQueue(__privateGet(this, _maxPoolSize)));\n    __privateSet(this, _sourceCoins, options.sourceCoins ? new Map(options.sourceCoins.map(id => [id, null])) : null);\n  }\n  resetCache() {\n    __privateSet(this, _gasPrice, null);\n    return __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateGet(this, _cache).reset());\n  }\n  async waitForLastTransaction() {\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this));\n  }\n  async executeTransaction(transaction, options, additionalSignatures = []) {\n    const {\n      promise,\n      resolve,\n      reject\n    } = promiseWithResolvers();\n    const usedObjects = await __privateMethod(this, _ParallelTransactionExecutor_instances, getUsedObjects_fn).call(this, transaction);\n    const execute = () => {\n      __privateGet(this, _executeQueue).runTask(() => {\n        const promise2 = __privateMethod(this, _ParallelTransactionExecutor_instances, execute_fn).call(this, transaction, usedObjects, options, additionalSignatures);\n        return promise2.then(resolve, reject);\n      });\n    };\n    const conflicts = /* @__PURE__ */new Set();\n    usedObjects.forEach(objectId => {\n      const queue = __privateGet(this, _objectIdQueues).get(objectId);\n      if (queue) {\n        conflicts.add(objectId);\n        __privateGet(this, _objectIdQueues).get(objectId).push(() => {\n          conflicts.delete(objectId);\n          if (conflicts.size === 0) {\n            execute();\n          }\n        });\n      } else {\n        __privateGet(this, _objectIdQueues).set(objectId, []);\n      }\n    });\n    if (conflicts.size === 0) {\n      execute();\n    }\n    return promise;\n  }\n}\n_signer = new WeakMap();\n_client = new WeakMap();\n_coinBatchSize = new WeakMap();\n_initialCoinBalance = new WeakMap();\n_minimumCoinBalance = new WeakMap();\n_epochBoundaryWindow = new WeakMap();\n_defaultGasBudget = new WeakMap();\n_maxPoolSize = new WeakMap();\n_sourceCoins = new WeakMap();\n_coinPool = new WeakMap();\n_cache = new WeakMap();\n_objectIdQueues = new WeakMap();\n_buildQueue = new WeakMap();\n_executeQueue = new WeakMap();\n_lastDigest = new WeakMap();\n_cacheLock = new WeakMap();\n_pendingTransactions = new WeakMap();\n_gasPrice = new WeakMap();\n_ParallelTransactionExecutor_instances = new WeakSet();\ngetUsedObjects_fn = async function (transaction) {\n  const usedObjects = /* @__PURE__ */new Set();\n  let serialized = false;\n  transaction.addSerializationPlugin(async (blockData, _options, next) => {\n    await next();\n    if (serialized) {\n      return;\n    }\n    serialized = true;\n    blockData.inputs.forEach(input => {\n      if (input.Object?.ImmOrOwnedObject?.objectId) {\n        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n      } else if (input.Object?.Receiving?.objectId) {\n        usedObjects.add(input.Object.Receiving.objectId);\n      } else if (input.UnresolvedObject?.objectId && !input.UnresolvedObject.initialSharedVersion) {\n        usedObjects.add(input.UnresolvedObject.objectId);\n      }\n    });\n  });\n  await transaction.prepareForSerialization({\n    client: __privateGet(this, _client)\n  });\n  return usedObjects;\n};\nexecute_fn = async function (transaction, usedObjects, options, additionalSignatures = []) {\n  let gasCoin;\n  try {\n    transaction.setSenderIfNotSet(__privateGet(this, _signer).toSuiAddress());\n    await __privateGet(this, _buildQueue).runTask(async () => {\n      const data = transaction.getData();\n      if (!data.gasData.price) {\n        transaction.setGasPrice(await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));\n      }\n      transaction.setGasBudgetIfNotSet(__privateGet(this, _defaultGasBudget));\n      await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);\n      gasCoin = await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);\n      __privateWrapper(this, _pendingTransactions)._++;\n      transaction.setGasPayment([{\n        objectId: gasCoin.id,\n        version: gasCoin.version,\n        digest: gasCoin.digest\n      }]);\n      await __privateGet(this, _cache).buildTransaction({\n        transaction,\n        onlyTransactionKind: true\n      });\n    });\n    const bytes = await transaction.build({\n      client: __privateGet(this, _client)\n    });\n    const {\n      signature\n    } = await __privateGet(this, _signer).signTransaction(bytes);\n    const results = await __privateGet(this, _cache).executeTransaction({\n      transaction: bytes,\n      signature: [signature, ...additionalSignatures],\n      options: {\n        ...options,\n        showEffects: true\n      }\n    });\n    const effectsBytes = Uint8Array.from(results.rawEffects);\n    const effects = bcs.TransactionEffects.parse(effectsBytes);\n    const gasResult = getGasCoinFromEffects(effects);\n    const gasUsed = effects.V2?.gasUsed;\n    if (gasCoin && gasUsed && gasResult.owner === __privateGet(this, _signer).toSuiAddress()) {\n      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);\n      const remainingBalance = gasCoin.balance - totalUsed;\n      let usesGasCoin = false;\n      new TransactionDataBuilder(transaction.getData()).mapArguments(arg => {\n        if (arg.$kind === \"GasCoin\") {\n          usesGasCoin = true;\n        }\n        return arg;\n      });\n      if (!usesGasCoin && remainingBalance >= __privateGet(this, _minimumCoinBalance)) {\n        __privateGet(this, _coinPool).push({\n          id: gasResult.ref.objectId,\n          version: gasResult.ref.version,\n          digest: gasResult.ref.digest,\n          balance: remainingBalance\n        });\n      } else {\n        if (!__privateGet(this, _sourceCoins)) {\n          __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n        }\n        __privateGet(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);\n      }\n    }\n    __privateSet(this, _lastDigest, results.digest);\n    return {\n      digest: results.digest,\n      effects: toBase64(effectsBytes),\n      data: results\n    };\n  } catch (error) {\n    if (gasCoin) {\n      if (!__privateGet(this, _sourceCoins)) {\n        __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n      }\n      __privateGet(this, _sourceCoins).set(gasCoin.id, null);\n    }\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {\n      await Promise.all([__privateGet(this, _cache).cache.deleteObjects([...usedObjects]), __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)]);\n    });\n    throw error;\n  } finally {\n    usedObjects.forEach(objectId => {\n      const queue = __privateGet(this, _objectIdQueues).get(objectId);\n      if (queue && queue.length > 0) {\n        queue.shift()();\n      } else if (queue) {\n        __privateGet(this, _objectIdQueues).delete(objectId);\n      }\n    });\n    __privateWrapper(this, _pendingTransactions)._--;\n  }\n};\nupdateCache_fn = async function (fn) {\n  if (__privateGet(this, _cacheLock)) {\n    await __privateGet(this, _cacheLock);\n  }\n  __privateSet(this, _cacheLock, fn?.().then(() => {\n    __privateSet(this, _cacheLock, null);\n  }, () => {}) ?? null);\n};\nwaitForLastDigest_fn = async function () {\n  const digest = __privateGet(this, _lastDigest);\n  if (digest) {\n    __privateSet(this, _lastDigest, null);\n    await __privateGet(this, _client).waitForTransaction({\n      digest\n    });\n  }\n};\ngetGasCoin_fn = async function () {\n  if (__privateGet(this, _coinPool).length === 0 && __privateGet(this, _pendingTransactions) <= __privateGet(this, _maxPoolSize)) {\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);\n  }\n  if (__privateGet(this, _coinPool).length === 0) {\n    throw new Error(\"No coins available\");\n  }\n  const coin = __privateGet(this, _coinPool).shift();\n  return coin;\n};\ngetGasPrice_fn = async function () {\n  const remaining = __privateGet(this, _gasPrice) ? __privateGet(this, _gasPrice).expiration - __privateGet(this, _epochBoundaryWindow) - Date.now() : 0;\n  if (remaining > 0) {\n    return __privateGet(this, _gasPrice).price;\n  }\n  if (__privateGet(this, _gasPrice)) {\n    const timeToNextEpoch = Math.max(__privateGet(this, _gasPrice).expiration + __privateGet(this, _epochBoundaryWindow) - Date.now(), 1e3);\n    await new Promise(resolve => setTimeout(resolve, timeToNextEpoch));\n  }\n  const state = await __privateGet(this, _client).getLatestSuiSystemState();\n  __privateSet(this, _gasPrice, {\n    price: BigInt(state.referenceGasPrice),\n    expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)\n  });\n  return __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);\n};\nrefillCoinPool_fn = async function () {\n  const batchSize = Math.min(__privateGet(this, _coinBatchSize), __privateGet(this, _maxPoolSize) - (__privateGet(this, _coinPool).length + __privateGet(this, _pendingTransactions)) + 1);\n  if (batchSize === 0) {\n    return;\n  }\n  const txb = new Transaction();\n  const address = __privateGet(this, _signer).toSuiAddress();\n  txb.setSender(address);\n  if (__privateGet(this, _sourceCoins)) {\n    const refs = [];\n    const ids = [];\n    for (const [id, ref] of __privateGet(this, _sourceCoins)) {\n      if (ref) {\n        refs.push(ref);\n      } else {\n        ids.push(id);\n      }\n    }\n    if (ids.length > 0) {\n      const coins = await __privateGet(this, _client).multiGetObjects({\n        ids\n      });\n      refs.push(...coins.filter(coin => coin.data !== null).map(({\n        data\n      }) => ({\n        objectId: data.objectId,\n        version: data.version,\n        digest: data.digest\n      })));\n    }\n    txb.setGasPayment(refs);\n    __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n  }\n  const amounts = new Array(batchSize).fill(__privateGet(this, _initialCoinBalance));\n  const results = txb.splitCoins(txb.gas, amounts);\n  const coinResults = [];\n  for (let i = 0; i < amounts.length; i++) {\n    coinResults.push(results[i]);\n  }\n  txb.transferObjects(coinResults, address);\n  await this.waitForLastTransaction();\n  const result = await __privateGet(this, _client).signAndExecuteTransaction({\n    transaction: txb,\n    signer: __privateGet(this, _signer),\n    options: {\n      showRawEffects: true\n    }\n  });\n  const effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));\n  effects.V2?.changedObjects.forEach(([id, {\n    outputState\n  }], i) => {\n    if (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {\n      return;\n    }\n    __privateGet(this, _coinPool).push({\n      id,\n      version: effects.V2.lamportVersion,\n      digest: outputState.ObjectWrite[0],\n      balance: BigInt(__privateGet(this, _initialCoinBalance))\n    });\n  });\n  if (!__privateGet(this, _sourceCoins)) {\n    __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n  }\n  const gasObject = getGasCoinFromEffects(effects).ref;\n  __privateGet(this, _sourceCoins).set(gasObject.objectId, gasObject);\n  await __privateGet(this, _client).waitForTransaction({\n    digest: result.digest\n  });\n};\nexport { ParallelTransactionExecutor };","map":{"version":3,"names":["_signer","_client","_coinBatchSize","_initialCoinBalance","_minimumCoinBalance","_epochBoundaryWindow","_defaultGasBudget","_maxPoolSize","_sourceCoins","_coinPool","_cache","_objectIdQueues","_buildQueue","_executeQueue","_lastDigest","_cacheLock","_pendingTransactions","_gasPrice","_ParallelTransactionExecutor_instances","getUsedObjects_fn","execute_fn","updateCache_fn","waitForLastDigest_fn","getGasCoin_fn","getGasPrice_fn","refillCoinPool_fn","toBase64","promiseWithResolvers","bcs","Transaction","TransactionDataBuilder","CachingTransactionExecutor","ParallelQueue","SerialQueue","getGasCoinFromEffects","PARALLEL_EXECUTOR_DEFAULTS","coinBatchSize","initialCoinBalance","minimumCoinBalance","maxPoolSize","epochBoundaryWindow","ParallelTransactionExecutor","constructor","options","__privateAdd","Map","__privateSet","signer","client","defaultGasBudget","__privateGet","cache","sourceCoins","map","id","resetCache","__privateMethod","call","reset","waitForLastTransaction","executeTransaction","transaction","additionalSignatures","promise","resolve","reject","usedObjects","execute","runTask","promise2","then","conflicts","Set","forEach","objectId","queue","get","add","push","delete","size","set","WeakMap","WeakSet","serialized","addSerializationPlugin","blockData","_options","next","inputs","input","Object","ImmOrOwnedObject","Receiving","UnresolvedObject","initialSharedVersion","prepareForSerialization","gasCoin","setSenderIfNotSet","toSuiAddress","data","getData","gasData","price","setGasPrice","setGasBudgetIfNotSet","__privateWrapper","_","setGasPayment","version","digest","buildTransaction","onlyTransactionKind","bytes","build","signature","signTransaction","results","showEffects","effectsBytes","Uint8Array","from","rawEffects","effects","TransactionEffects","parse","gasResult","gasUsed","V2","owner","totalUsed","BigInt","computationCost","storageCost","storageRebate","remainingBalance","balance","usesGasCoin","mapArguments","arg","$kind","ref","error","Promise","all","deleteObjects","length","shift","fn","waitForTransaction","Error","coin","remaining","expiration","Date","now","timeToNextEpoch","Math","max","setTimeout","state","getLatestSuiSystemState","referenceGasPrice","Number","parseInt","epochStartTimestampMs","epochDurationMs","batchSize","min","txb","address","setSender","refs","ids","coins","multiGetObjects","filter","amounts","Array","fill","splitCoins","gas","coinResults","i","transferObjects","result","signAndExecuteTransaction","showRawEffects","changedObjects","outputState","gasObjectIndex","ObjectWrite","lamportVersion","gasObject"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/sui/src/transactions/executor/parallel.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport { promiseWithResolvers } from '@mysten/utils';\nimport { bcs } from '../../bcs/index.js';\nimport type { SuiObjectRef } from '../../bcs/types.js';\nimport type {\n\tSuiClient,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseOptions,\n} from '../../client/index.js';\nimport type { Signer } from '../../cryptography/index.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { Transaction } from '../Transaction.js';\nimport { TransactionDataBuilder } from '../TransactionData.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { ParallelQueue, SerialQueue } from './queue.js';\nimport { getGasCoinFromEffects } from './serial.js';\n\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n\tcoinBatchSize: 20,\n\tinitialCoinBalance: 200_000_000n,\n\tminimumCoinBalance: 50_000_000n,\n\tmaxPoolSize: 50,\n\tepochBoundaryWindow: 1_000,\n} satisfies Omit<ParallelTransactionExecutorOptions, 'signer' | 'client'>;\nexport interface ParallelTransactionExecutorOptions extends Omit<ObjectCacheOptions, 'address'> {\n\tclient: SuiClient;\n\tsigner: Signer;\n\t/** The number of coins to create in a batch when refilling the gas pool */\n\tcoinBatchSize?: number;\n\t/** The initial balance of each coin created for the gas pool */\n\tinitialCoinBalance?: bigint;\n\t/** The minimum balance of a coin that can be reused for future transactions.  If the gasCoin is below this value, it will be used when refilling the gasPool */\n\tminimumCoinBalance?: bigint;\n\t/** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `minimumCoinBalance` */\n\tdefaultGasBudget?: bigint;\n\t/**\n\t * Time to wait before/after the expected epoch boundary before re-fetching the gas pool (in milliseconds).\n\t * Building transactions will be paused for up to 2x this duration around each epoch boundary to ensure the\n\t * gas price is up-to-date for the next epoch.\n\t * */\n\tepochBoundaryWindow?: number;\n\t/** The maximum number of transactions that can be execute in parallel, this also determines the maximum number of gas coins that will be created */\n\tmaxPoolSize?: number;\n\t/** An initial list of coins used to fund the gas pool, uses all owned SUI coins by default */\n\tsourceCoins?: string[];\n}\n\ninterface CoinWithBalance {\n\tid: string;\n\tversion: string;\n\tdigest: string;\n\tbalance: bigint;\n}\nexport class ParallelTransactionExecutor {\n\t#signer: Signer;\n\t#client: SuiClient;\n\t#coinBatchSize: number;\n\t#initialCoinBalance: bigint;\n\t#minimumCoinBalance: bigint;\n\t#epochBoundaryWindow: number;\n\t#defaultGasBudget: bigint;\n\t#maxPoolSize: number;\n\t#sourceCoins: Map<string, SuiObjectRef | null> | null;\n\t#coinPool: CoinWithBalance[] = [];\n\t#cache: CachingTransactionExecutor;\n\t#objectIdQueues = new Map<string, (() => void)[]>();\n\t#buildQueue = new SerialQueue();\n\t#executeQueue: ParallelQueue;\n\t#lastDigest: string | null = null;\n\t#cacheLock: Promise<void> | null = null;\n\t#pendingTransactions = 0;\n\t#gasPrice: null | {\n\t\tprice: bigint;\n\t\texpiration: number;\n\t} = null;\n\n\tconstructor(options: ParallelTransactionExecutorOptions) {\n\t\tthis.#signer = options.signer;\n\t\tthis.#client = options.client;\n\t\tthis.#coinBatchSize = options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize;\n\t\tthis.#initialCoinBalance =\n\t\t\toptions.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance;\n\t\tthis.#minimumCoinBalance =\n\t\t\toptions.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance;\n\t\tthis.#defaultGasBudget = options.defaultGasBudget ?? this.#minimumCoinBalance;\n\t\tthis.#epochBoundaryWindow =\n\t\t\toptions.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow;\n\t\tthis.#maxPoolSize = options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize;\n\t\tthis.#cache = new CachingTransactionExecutor({\n\t\t\tclient: options.client,\n\t\t\tcache: options.cache,\n\t\t});\n\t\tthis.#executeQueue = new ParallelQueue(this.#maxPoolSize);\n\t\tthis.#sourceCoins = options.sourceCoins\n\t\t\t? new Map(options.sourceCoins.map((id) => [id, null]))\n\t\t\t: null;\n\t}\n\n\tresetCache() {\n\t\tthis.#gasPrice = null;\n\t\treturn this.#updateCache(() => this.#cache.reset());\n\t}\n\n\tasync waitForLastTransaction() {\n\t\tawait this.#updateCache(() => this.#waitForLastDigest());\n\t}\n\n\tasync executeTransaction(\n\t\ttransaction: Transaction,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t\tadditionalSignatures: string[] = [],\n\t) {\n\t\tconst { promise, resolve, reject } = promiseWithResolvers<{\n\t\t\tdigest: string;\n\t\t\teffects: string;\n\t\t\tdata: SuiTransactionBlockResponse;\n\t\t}>();\n\t\tconst usedObjects = await this.#getUsedObjects(transaction);\n\n\t\tconst execute = () => {\n\t\t\tthis.#executeQueue.runTask(() => {\n\t\t\t\tconst promise = this.#execute(transaction, usedObjects, options, additionalSignatures);\n\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t});\n\t\t};\n\n\t\tconst conflicts = new Set<string>();\n\n\t\tusedObjects.forEach((objectId) => {\n\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\tif (queue) {\n\t\t\t\tconflicts.add(objectId);\n\t\t\t\tthis.#objectIdQueues.get(objectId)!.push(() => {\n\t\t\t\t\tconflicts.delete(objectId);\n\t\t\t\t\tif (conflicts.size === 0) {\n\t\t\t\t\t\texecute();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.#objectIdQueues.set(objectId, []);\n\t\t\t}\n\t\t});\n\n\t\tif (conflicts.size === 0) {\n\t\t\texecute();\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tasync #getUsedObjects(transaction: Transaction) {\n\t\tconst usedObjects = new Set<string>();\n\t\tlet serialized = false;\n\n\t\ttransaction.addSerializationPlugin(async (blockData, _options, next) => {\n\t\t\tawait next();\n\n\t\t\tif (serialized) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tserialized = true;\n\n\t\t\tblockData.inputs.forEach((input) => {\n\t\t\t\tif (input.Object?.ImmOrOwnedObject?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t\t\t} else if (input.Object?.Receiving?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.Receiving.objectId);\n\t\t\t\t} else if (\n\t\t\t\t\tinput.UnresolvedObject?.objectId &&\n\t\t\t\t\t!input.UnresolvedObject.initialSharedVersion\n\t\t\t\t) {\n\t\t\t\t\tusedObjects.add(input.UnresolvedObject.objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tawait transaction.prepareForSerialization({ client: this.#client });\n\n\t\treturn usedObjects;\n\t}\n\n\tasync #execute(\n\t\ttransaction: Transaction,\n\t\tusedObjects: Set<string>,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t\tadditionalSignatures: string[] = [],\n\t) {\n\t\tlet gasCoin!: CoinWithBalance;\n\t\ttry {\n\t\t\ttransaction.setSenderIfNotSet(this.#signer.toSuiAddress());\n\n\t\t\tawait this.#buildQueue.runTask(async () => {\n\t\t\t\tconst data = transaction.getData();\n\n\t\t\t\tif (!data.gasData.price) {\n\t\t\t\t\ttransaction.setGasPrice(await this.#getGasPrice());\n\t\t\t\t}\n\n\t\t\t\ttransaction.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\n\t\t\t\tawait this.#updateCache();\n\t\t\t\tgasCoin = await this.#getGasCoin();\n\t\t\t\tthis.#pendingTransactions++;\n\t\t\t\ttransaction.setGasPayment([\n\t\t\t\t\t{\n\t\t\t\t\t\tobjectId: gasCoin.id,\n\t\t\t\t\t\tversion: gasCoin.version,\n\t\t\t\t\t\tdigest: gasCoin.digest,\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\t// Resolve cached references\n\t\t\t\tawait this.#cache.buildTransaction({ transaction, onlyTransactionKind: true });\n\t\t\t});\n\n\t\t\tconst bytes = await transaction.build({ client: this.#client });\n\n\t\t\tconst { signature } = await this.#signer.signTransaction(bytes);\n\n\t\t\tconst results = await this.#cache.executeTransaction({\n\t\t\t\ttransaction: bytes,\n\t\t\t\tsignature: [signature, ...additionalSignatures],\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tshowEffects: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst effectsBytes = Uint8Array.from(results.rawEffects!);\n\t\t\tconst effects = bcs.TransactionEffects.parse(effectsBytes);\n\n\t\t\tconst gasResult = getGasCoinFromEffects(effects);\n\t\t\tconst gasUsed = effects.V2?.gasUsed;\n\n\t\t\tif (gasCoin && gasUsed && gasResult.owner === this.#signer.toSuiAddress()) {\n\t\t\t\tconst totalUsed =\n\t\t\t\t\tBigInt(gasUsed.computationCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) -\n\t\t\t\t\tBigInt(gasUsed.storageRebate);\n\t\t\t\tconst remainingBalance = gasCoin.balance - totalUsed;\n\n\t\t\t\tlet usesGasCoin = false;\n\t\t\t\tnew TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {\n\t\t\t\t\tif (arg.$kind === 'GasCoin') {\n\t\t\t\t\t\tusesGasCoin = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arg;\n\t\t\t\t});\n\n\t\t\t\tif (!usesGasCoin && remainingBalance >= this.#minimumCoinBalance) {\n\t\t\t\t\tthis.#coinPool.push({\n\t\t\t\t\t\tid: gasResult.ref.objectId,\n\t\t\t\t\t\tversion: gasResult.ref.version,\n\t\t\t\t\t\tdigest: gasResult.ref.digest,\n\t\t\t\t\t\tbalance: remainingBalance,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t\t}\n\t\t\t\t\tthis.#sourceCoins.set(gasResult.ref.objectId, gasResult.ref);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.#lastDigest = results.digest;\n\n\t\t\treturn {\n\t\t\t\tdigest: results.digest,\n\t\t\t\teffects: toBase64(effectsBytes),\n\t\t\t\tdata: results,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (gasCoin) {\n\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t}\n\n\t\t\t\tthis.#sourceCoins.set(gasCoin.id, null);\n\t\t\t}\n\n\t\t\tawait this.#updateCache(async () => {\n\t\t\t\tawait Promise.all([\n\t\t\t\t\tthis.#cache.cache.deleteObjects([...usedObjects]),\n\t\t\t\t\tthis.#waitForLastDigest(),\n\t\t\t\t]);\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tusedObjects.forEach((objectId) => {\n\t\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\t\tif (queue && queue.length > 0) {\n\t\t\t\t\tqueue.shift()!();\n\t\t\t\t} else if (queue) {\n\t\t\t\t\tthis.#objectIdQueues.delete(objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.#pendingTransactions--;\n\t\t}\n\t}\n\n\t/** Helper for synchronizing cache updates, by ensuring only one update happens at a time.  This can also be used to wait for any pending cache updates  */\n\tasync #updateCache(fn?: () => Promise<void>) {\n\t\tif (this.#cacheLock) {\n\t\t\tawait this.#cacheLock;\n\t\t}\n\n\t\tthis.#cacheLock =\n\t\t\tfn?.().then(\n\t\t\t\t() => {\n\t\t\t\t\tthis.#cacheLock = null;\n\t\t\t\t},\n\t\t\t\t() => {},\n\t\t\t) ?? null;\n\t}\n\n\tasync #waitForLastDigest() {\n\t\tconst digest = this.#lastDigest;\n\t\tif (digest) {\n\t\t\tthis.#lastDigest = null;\n\t\t\tawait this.#client.waitForTransaction({ digest });\n\t\t}\n\t}\n\n\tasync #getGasCoin() {\n\t\tif (this.#coinPool.length === 0 && this.#pendingTransactions <= this.#maxPoolSize) {\n\t\t\tawait this.#refillCoinPool();\n\t\t}\n\n\t\tif (this.#coinPool.length === 0) {\n\t\t\tthrow new Error('No coins available');\n\t\t}\n\n\t\tconst coin = this.#coinPool.shift()!;\n\t\treturn coin;\n\t}\n\n\tasync #getGasPrice(): Promise<bigint> {\n\t\tconst remaining = this.#gasPrice\n\t\t\t? this.#gasPrice.expiration - this.#epochBoundaryWindow - Date.now()\n\t\t\t: 0;\n\n\t\tif (remaining > 0) {\n\t\t\treturn this.#gasPrice!.price;\n\t\t}\n\n\t\tif (this.#gasPrice) {\n\t\t\tconst timeToNextEpoch = Math.max(\n\t\t\t\tthis.#gasPrice.expiration + this.#epochBoundaryWindow - Date.now(),\n\t\t\t\t1_000,\n\t\t\t);\n\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));\n\t\t}\n\n\t\tconst state = await this.#client.getLatestSuiSystemState();\n\n\t\tthis.#gasPrice = {\n\t\t\tprice: BigInt(state.referenceGasPrice),\n\t\t\texpiration:\n\t\t\t\tNumber.parseInt(state.epochStartTimestampMs, 10) +\n\t\t\t\tNumber.parseInt(state.epochDurationMs, 10),\n\t\t};\n\n\t\treturn this.#getGasPrice();\n\t}\n\n\tasync #refillCoinPool() {\n\t\tconst batchSize = Math.min(\n\t\t\tthis.#coinBatchSize,\n\t\t\tthis.#maxPoolSize - (this.#coinPool.length + this.#pendingTransactions) + 1,\n\t\t);\n\n\t\tif (batchSize === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst txb = new Transaction();\n\t\tconst address = this.#signer.toSuiAddress();\n\t\ttxb.setSender(address);\n\n\t\tif (this.#sourceCoins) {\n\t\t\tconst refs = [];\n\t\t\tconst ids = [];\n\t\t\tfor (const [id, ref] of this.#sourceCoins) {\n\t\t\t\tif (ref) {\n\t\t\t\t\trefs.push(ref);\n\t\t\t\t} else {\n\t\t\t\t\tids.push(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ids.length > 0) {\n\t\t\t\tconst coins = await this.#client.multiGetObjects({\n\t\t\t\t\tids,\n\t\t\t\t});\n\t\t\t\trefs.push(\n\t\t\t\t\t...coins\n\t\t\t\t\t\t.filter((coin): coin is typeof coin & { data: object } => coin.data !== null)\n\t\t\t\t\t\t.map(({ data }) => ({\n\t\t\t\t\t\t\tobjectId: data.objectId,\n\t\t\t\t\t\t\tversion: data.version,\n\t\t\t\t\t\t\tdigest: data.digest,\n\t\t\t\t\t\t})),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttxb.setGasPayment(refs);\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst amounts = new Array(batchSize).fill(this.#initialCoinBalance);\n\t\tconst results = txb.splitCoins(txb.gas, amounts);\n\t\tconst coinResults = [];\n\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\tcoinResults.push(results[i]);\n\t\t}\n\t\ttxb.transferObjects(coinResults, address);\n\n\t\tawait this.waitForLastTransaction();\n\n\t\tconst result = await this.#client.signAndExecuteTransaction({\n\t\t\ttransaction: txb,\n\t\t\tsigner: this.#signer,\n\t\t\toptions: {\n\t\t\t\tshowRawEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tconst effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects!));\n\t\teffects.V2?.changedObjects.forEach(([id, { outputState }], i) => {\n\t\t\tif (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.#coinPool.push({\n\t\t\t\tid,\n\t\t\t\tversion: effects.V2!.lamportVersion,\n\t\t\t\tdigest: outputState.ObjectWrite[0],\n\t\t\t\tbalance: BigInt(this.#initialCoinBalance),\n\t\t\t});\n\t\t});\n\n\t\tif (!this.#sourceCoins) {\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst gasObject = getGasCoinFromEffects(effects).ref;\n\t\tthis.#sourceCoins!.set(gasObject.objectId, gasObject);\n\n\t\tawait this.#client.waitForTransaction({ digest: result.digest });\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}