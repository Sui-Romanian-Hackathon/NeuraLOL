{"ast":null,"code":"import { Inputs } from \"./Inputs.js\";\nimport { bcs } from \"../bcs/index.js\";\nimport { jsonRpcClientResolveTransactionPlugin } from \"../jsonRpc/json-rpc-resolver.js\";\nfunction needsTransactionResolution(data, options) {\n  if (data.inputs.some(input => {\n    return input.UnresolvedObject || input.UnresolvedPure;\n  })) {\n    return true;\n  }\n  if (!options.onlyTransactionKind) {\n    if (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n      return true;\n    }\n  }\n  return false;\n}\nasync function resolveTransactionPlugin(transactionData, options, next) {\n  normalizeRawArguments(transactionData);\n  if (!needsTransactionResolution(transactionData, options)) {\n    await validate(transactionData);\n    return next();\n  }\n  const client = getClient(options);\n  const plugin = client.core?.resolveTransactionPlugin() ?? jsonRpcClientResolveTransactionPlugin(client);\n  return plugin(transactionData, options, async () => {\n    await validate(transactionData);\n    await next();\n  });\n}\nfunction validate(transactionData) {\n  transactionData.inputs.forEach((input, index) => {\n    if (input.$kind !== \"Object\" && input.$kind !== \"Pure\") {\n      throw new Error(`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(input)}`);\n    }\n  });\n}\nfunction getClient(options) {\n  if (!options.client) {\n    throw new Error(`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`);\n  }\n  return options.client;\n}\nfunction normalizeRawArguments(transactionData) {\n  for (const command of transactionData.commands) {\n    switch (command.$kind) {\n      case \"SplitCoins\":\n        command.SplitCoins.amounts.forEach(amount => {\n          normalizeRawArgument(amount, bcs.U64, transactionData);\n        });\n        break;\n      case \"TransferObjects\":\n        normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n        break;\n    }\n  }\n}\nfunction normalizeRawArgument(arg, schema, transactionData) {\n  if (arg.$kind !== \"Input\") {\n    return;\n  }\n  const input = transactionData.inputs[arg.Input];\n  if (input.$kind !== \"UnresolvedPure\") {\n    return;\n  }\n  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\nexport { getClient, needsTransactionResolution, resolveTransactionPlugin };","map":{"version":3,"names":["Inputs","bcs","jsonRpcClientResolveTransactionPlugin","needsTransactionResolution","data","options","inputs","some","input","UnresolvedObject","UnresolvedPure","onlyTransactionKind","gasConfig","price","budget","payment","resolveTransactionPlugin","transactionData","next","normalizeRawArguments","validate","client","getClient","plugin","core","forEach","index","$kind","Error","JSON","stringify","command","commands","SplitCoins","amounts","amount","normalizeRawArgument","U64","TransferObjects","address","Address","arg","schema","Input","Pure","serialize","value"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/sui/src/transactions/resolve.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Argument } from './data/internal.js';\n\nimport type { ClientWithCoreApi } from '../experimental/index.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\nimport type { BcsType } from '@mysten/bcs';\nimport { Inputs } from './Inputs.js';\nimport { bcs } from '../bcs/index.js';\nimport { jsonRpcClientResolveTransactionPlugin } from '../jsonRpc/json-rpc-resolver.js';\nimport type { SuiJsonRpcClient } from '../jsonRpc/client.js';\n\nexport interface BuildTransactionOptions {\n\tclient?: ClientWithCoreApi;\n\tonlyTransactionKind?: boolean;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n\tsupportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) => Promise<void>;\n\nexport function needsTransactionResolution(\n\tdata: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n): boolean {\n\tif (\n\t\tdata.inputs.some((input) => {\n\t\t\treturn input.UnresolvedObject || input.UnresolvedPure;\n\t\t})\n\t) {\n\t\treturn true;\n\t}\n\n\tif (!options.onlyTransactionKind) {\n\t\tif (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport async function resolveTransactionPlugin(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tnormalizeRawArguments(transactionData);\n\tif (!needsTransactionResolution(transactionData, options)) {\n\t\tawait validate(transactionData);\n\t\treturn next();\n\t}\n\n\tconst client = getClient(options);\n\tconst plugin =\n\t\tclient.core?.resolveTransactionPlugin() ??\n\t\tjsonRpcClientResolveTransactionPlugin(client as SuiJsonRpcClient);\n\n\treturn plugin(transactionData, options, async () => {\n\t\tawait validate(transactionData);\n\t\tawait next();\n\t});\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n\ttransactionData.inputs.forEach((input, index) => {\n\t\tif (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n\t\t\tthrow new Error(\n\t\t\t\t`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n\t\t\t\t\tinput,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\t});\n}\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nfunction normalizeRawArguments(transactionData: TransactionDataBuilder) {\n\tfor (const command of transactionData.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.amounts.forEach((amount) => {\n\t\t\t\t\tnormalizeRawArgument(amount, bcs.U64, transactionData);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tnormalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction normalizeRawArgument(\n\targ: Argument,\n\tschema: BcsType<any>,\n\ttransactionData: TransactionDataBuilder,\n) {\n\tif (arg.$kind !== 'Input') {\n\t\treturn;\n\t}\n\tconst input = transactionData.inputs[arg.Input];\n\n\tif (input.$kind !== 'UnresolvedPure') {\n\t\treturn;\n\t}\n\n\ttransactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}