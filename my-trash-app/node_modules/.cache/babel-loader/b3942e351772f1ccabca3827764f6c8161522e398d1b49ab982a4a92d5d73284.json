{"ast":null,"code":"import { parse } from \"valibot\";\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from \"../utils/index.js\";\nimport { ObjectRefSchema } from \"../transactions/data/internal.js\";\nimport { Inputs } from \"../transactions/Inputs.js\";\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from \"../transactions/serializer.js\";\nimport { chunk } from \"@mysten/utils\";\nconst MAX_OBJECTS_PER_FETCH = 50;\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 5e10;\nfunction jsonRpcClientResolveTransactionPlugin(client) {\n  return async function resolveTransactionData(transactionData, options, next) {\n    await normalizeInputs(transactionData, client);\n    await resolveObjectReferences(transactionData, client);\n    if (!options.onlyTransactionKind) {\n      await setGasPrice(transactionData, client);\n      await setGasBudget(transactionData, client);\n      await setGasPayment(transactionData, client);\n    }\n    return await next();\n  };\n}\nasync function setGasPrice(transactionData, client) {\n  if (!transactionData.gasConfig.price) {\n    transactionData.gasConfig.price = String(await client.getReferenceGasPrice());\n  }\n}\nasync function setGasBudget(transactionData, client) {\n  if (transactionData.gasConfig.budget) {\n    return;\n  }\n  const dryRunResult = await client.dryRunTransactionBlock({\n    transactionBlock: transactionData.build({\n      overrides: {\n        gasData: {\n          budget: String(MAX_GAS),\n          payment: []\n        }\n      }\n    })\n  });\n  if (dryRunResult.effects.status.status !== \"success\") {\n    throw new Error(`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`, {\n      cause: dryRunResult\n    });\n  }\n  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n  transactionData.gasConfig.budget = String(gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead);\n}\nasync function setGasPayment(transactionData, client) {\n  if (!transactionData.gasConfig.payment) {\n    const coins = await client.getCoins({\n      owner: transactionData.gasConfig.owner || transactionData.sender,\n      coinType: SUI_TYPE_ARG\n    });\n    const paymentCoins = coins.data.filter(coin => {\n      const matchingInput = transactionData.inputs.find(input => {\n        if (input.Object?.ImmOrOwnedObject) {\n          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n        }\n        return false;\n      });\n      return !matchingInput;\n    }).map(coin => ({\n      objectId: coin.coinObjectId,\n      digest: coin.digest,\n      version: coin.version\n    }));\n    if (!paymentCoins.length) {\n      throw new Error(\"No valid gas coins found for the transaction.\");\n    }\n    transactionData.gasConfig.payment = paymentCoins.map(payment => parse(ObjectRefSchema, payment));\n  }\n}\nasync function resolveObjectReferences(transactionData, client) {\n  const objectsToResolve = transactionData.inputs.filter(input => {\n    return input.UnresolvedObject && !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion);\n  });\n  const dedupedIds = [...new Set(objectsToResolve.map(input => normalizeSuiObjectId(input.UnresolvedObject.objectId)))];\n  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n  const resolved = (await Promise.all(objectChunks.map(chunk2 => client.multiGetObjects({\n    ids: chunk2,\n    options: {\n      showOwner: true\n    }\n  })))).flat();\n  const responsesById = new Map(dedupedIds.map((id, index) => {\n    return [id, resolved[index]];\n  }));\n  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));\n  if (invalidObjects.length) {\n    throw new Error(`The following input objects are invalid: ${invalidObjects.join(\", \")}`);\n  }\n  const objects = resolved.map(object => {\n    if (object.error || !object.data) {\n      throw new Error(`Failed to fetch object: ${object.error}`);\n    }\n    const owner = object.data.owner;\n    const initialSharedVersion = owner && typeof owner === \"object\" ? \"Shared\" in owner ? owner.Shared.initial_shared_version : \"ConsensusAddressOwner\" in owner ? owner.ConsensusAddressOwner.start_version : null : null;\n    return {\n      objectId: object.data.objectId,\n      digest: object.data.digest,\n      version: object.data.version,\n      initialSharedVersion\n    };\n  });\n  const objectsById = new Map(dedupedIds.map((id, index) => {\n    return [id, objects[index]];\n  }));\n  for (const [index, input] of transactionData.inputs.entries()) {\n    if (!input.UnresolvedObject) {\n      continue;\n    }\n    let updated;\n    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n    const object = objectsById.get(id);\n    if (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n      updated = Inputs.SharedObjectRef({\n        objectId: id,\n        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion,\n        mutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index)\n      });\n    } else if (isUsedAsReceiving(transactionData, index)) {\n      updated = Inputs.ReceivingRef({\n        objectId: id,\n        digest: input.UnresolvedObject.digest ?? object?.digest,\n        version: input.UnresolvedObject.version ?? object?.version\n      });\n    }\n    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({\n      objectId: id,\n      digest: input.UnresolvedObject.digest ?? object?.digest,\n      version: input.UnresolvedObject.version ?? object?.version\n    });\n  }\n}\nasync function normalizeInputs(transactionData, client) {\n  const {\n    inputs,\n    commands\n  } = transactionData;\n  const moveCallsToResolve = [];\n  const moveFunctionsToResolve = /* @__PURE__ */new Set();\n  commands.forEach(command => {\n    if (command.MoveCall) {\n      if (command.MoveCall._argumentTypes) {\n        return;\n      }\n      const inputs2 = command.MoveCall.arguments.map(arg => {\n        if (arg.$kind === \"Input\") {\n          return transactionData.inputs[arg.Input];\n        }\n        return null;\n      });\n      const needsResolution = inputs2.some(input => input?.UnresolvedPure || input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== \"boolean\");\n      if (needsResolution) {\n        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n        moveFunctionsToResolve.add(functionName);\n        moveCallsToResolve.push(command.MoveCall);\n      }\n    }\n  });\n  const moveFunctionParameters = /* @__PURE__ */new Map();\n  if (moveFunctionsToResolve.size > 0) {\n    await Promise.all([...moveFunctionsToResolve].map(async functionName => {\n      const [packageId, moduleId, functionId] = functionName.split(\"::\");\n      const def = await client.getNormalizedMoveFunction({\n        package: packageId,\n        module: moduleId,\n        function: functionId\n      });\n      moveFunctionParameters.set(functionName, def.parameters.map(param => normalizedTypeToMoveTypeSignature(param)));\n    }));\n  }\n  if (moveCallsToResolve.length) {\n    await Promise.all(moveCallsToResolve.map(async moveCall => {\n      const parameters = moveFunctionParameters.get(`${moveCall.package}::${moveCall.module}::${moveCall.function}`);\n      if (!parameters) {\n        return;\n      }\n      const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));\n      const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n      moveCall._argumentTypes = params;\n    }));\n  }\n  commands.forEach(command => {\n    if (!command.MoveCall) {\n      return;\n    }\n    const moveCall = command.MoveCall;\n    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n    const params = moveCall._argumentTypes;\n    if (!params) {\n      return;\n    }\n    if (params.length !== command.MoveCall.arguments.length) {\n      throw new Error(`Incorrect number of arguments for ${fnName}`);\n    }\n    params.forEach((param, i) => {\n      const arg = moveCall.arguments[i];\n      if (arg.$kind !== \"Input\") return;\n      const input = inputs[arg.Input];\n      if (!input.UnresolvedPure && !input.UnresolvedObject) {\n        return;\n      }\n      const inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId;\n      const schema = getPureBcsSchema(param.body);\n      if (schema) {\n        arg.type = \"pure\";\n        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n        return;\n      }\n      if (typeof inputValue !== \"string\") {\n        throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(inputValue, null, 2)}`);\n      }\n      arg.type = \"object\";\n      const unresolvedObject = input.UnresolvedPure ? {\n        $kind: \"UnresolvedObject\",\n        UnresolvedObject: {\n          objectId: inputValue\n        }\n      } : input;\n      inputs[arg.Input] = unresolvedObject;\n    });\n  });\n}\nfunction isUsedAsMutable(transactionData, index) {\n  let usedAsMutable = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== \"&\" || usedAsMutable;\n    }\n    if (tx.$kind === \"MakeMoveVec\" || tx.$kind === \"MergeCoins\" || tx.$kind === \"SplitCoins\" || tx.$kind === \"TransferObjects\") {\n      usedAsMutable = true;\n    }\n  });\n  return usedAsMutable;\n}\nfunction isUsedAsReceiving(transactionData, index) {\n  let usedAsReceiving = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n    }\n  });\n  return usedAsReceiving;\n}\nfunction isReceivingType(type) {\n  if (typeof type.body !== \"object\" || !(\"datatype\" in type.body)) {\n    return false;\n  }\n  return type.body.datatype.package === \"0x2\" && type.body.datatype.module === \"transfer\" && type.body.datatype.type === \"Receiving\";\n}\nexport { jsonRpcClientResolveTransactionPlugin };","map":{"version":3,"names":["parse","normalizeSuiAddress","normalizeSuiObjectId","SUI_TYPE_ARG","ObjectRefSchema","Inputs","getPureBcsSchema","isTxContext","normalizedTypeToMoveTypeSignature","chunk","MAX_OBJECTS_PER_FETCH","GAS_SAFE_OVERHEAD","MAX_GAS","jsonRpcClientResolveTransactionPlugin","client","resolveTransactionData","transactionData","options","next","normalizeInputs","resolveObjectReferences","onlyTransactionKind","setGasPrice","setGasBudget","setGasPayment","gasConfig","price","String","getReferenceGasPrice","budget","dryRunResult","dryRunTransactionBlock","transactionBlock","build","overrides","gasData","payment","effects","status","Error","error","cause","safeOverhead","BigInt","baseComputationCostWithOverhead","gasUsed","computationCost","gasBudget","storageCost","storageRebate","coins","getCoins","owner","sender","coinType","paymentCoins","data","filter","coin","matchingInput","inputs","find","input","Object","ImmOrOwnedObject","coinObjectId","objectId","map","digest","version","length","objectsToResolve","UnresolvedObject","initialSharedVersion","dedupedIds","Set","objectChunks","resolved","Promise","all","chunk2","multiGetObjects","ids","showOwner","flat","responsesById","Map","id","index","invalidObjects","Array","from","_","obj","JSON","stringify","join","objects","object","Shared","initial_shared_version","ConsensusAddressOwner","start_version","objectsById","entries","updated","get","SharedObjectRef","mutable","isUsedAsMutable","isUsedAsReceiving","ReceivingRef","indexOf","ObjectRef","commands","moveCallsToResolve","moveFunctionsToResolve","forEach","command","MoveCall","_argumentTypes","inputs2","arguments","arg","$kind","Input","needsResolution","some","UnresolvedPure","functionName","package","module","function","add","push","moveFunctionParameters","size","packageId","moduleId","functionId","split","def","getNormalizedMoveFunction","set","parameters","param","moveCall","hasTxContext","at","params","slice","fnName","i","inputValue","value","schema","body","type","Pure","serialize","unresolvedObject","usedAsMutable","getInputUses","tx","argIndex","ref","usedAsReceiving","isReceivingType","datatype"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/sui/src/jsonRpc/json-rpc-resolver.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRefSchema } from '../transactions/data/internal.js';\nimport type { CallArg, Command, OpenMoveTypeSignature } from '../transactions/data/internal.js';\nimport { Inputs } from '../transactions/Inputs.js';\nimport {\n\tgetPureBcsSchema,\n\tisTxContext,\n\tnormalizedTypeToMoveTypeSignature,\n} from '../transactions/serializer.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { chunk } from '@mysten/utils';\nimport type { BuildTransactionOptions } from '../transactions/index.js';\nimport type { SuiJsonRpcClient } from './client.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport function jsonRpcClientResolveTransactionPlugin(client: SuiJsonRpcClient) {\n\treturn async function resolveTransactionData(\n\t\ttransactionData: TransactionDataBuilder,\n\t\toptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) {\n\t\tawait normalizeInputs(transactionData, client);\n\t\tawait resolveObjectReferences(transactionData, client);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait setGasPrice(transactionData, client);\n\t\t\tawait setGasBudget(transactionData, client);\n\t\t\tawait setGasPayment(transactionData, client);\n\t\t}\n\n\t\treturn await next();\n\t};\n}\n\nasync function setGasPrice(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (!transactionData.gasConfig.price) {\n\t\ttransactionData.gasConfig.price = String(await client.getReferenceGasPrice());\n\t}\n}\n\nasync function setGasBudget(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (transactionData.gasConfig.budget) {\n\t\treturn;\n\t}\n\n\tconst dryRunResult = await client.dryRunTransactionBlock({\n\t\ttransactionBlock: transactionData.build({\n\t\t\toverrides: {\n\t\t\t\tgasData: {\n\t\t\t\t\tbudget: String(MAX_GAS),\n\t\t\t\t\tpayment: [],\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t});\n\n\tif (dryRunResult.effects.status.status !== 'success') {\n\t\tthrow new Error(\n\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t{ cause: dryRunResult },\n\t\t);\n\t}\n\n\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n\tconst baseComputationCostWithOverhead =\n\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\tconst gasBudget =\n\t\tbaseComputationCostWithOverhead +\n\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\ttransactionData.gasConfig.budget = String(\n\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t);\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (!transactionData.gasConfig.payment) {\n\t\tconst coins = await client.getCoins({\n\t\t\towner: transactionData.gasConfig.owner || transactionData.sender!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = transactionData.inputs.find((input) => {\n\t\t\t\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\ttransactionData.gasConfig.payment = paymentCoins.map((payment) =>\n\t\t\tparse(ObjectRefSchema, payment),\n\t\t);\n\t}\n}\n\nasync function resolveObjectReferences(\n\ttransactionData: TransactionDataBuilder,\n\tclient: SuiJsonRpcClient,\n) {\n\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t// We keep the input by-reference to avoid needing to re-resolve it:\n\tconst objectsToResolve = transactionData.inputs.filter((input) => {\n\t\treturn (\n\t\t\tinput.UnresolvedObject &&\n\t\t\t!(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n\t\t);\n\t}) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n\tconst dedupedIds = [\n\t\t...new Set(\n\t\t\tobjectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)),\n\t\t),\n\t];\n\n\tconst objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\tconst resolved = (\n\t\tawait Promise.all(\n\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\tclient.multiGetObjects({\n\t\t\t\t\tids: chunk,\n\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t).flat();\n\n\tconst responsesById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, resolved[index]];\n\t\t}),\n\t);\n\n\tconst invalidObjects = Array.from(responsesById)\n\t\t.filter(([_, obj]) => obj.error)\n\t\t.map(([_, obj]) => JSON.stringify(obj.error));\n\n\tif (invalidObjects.length) {\n\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t}\n\n\tconst objects = resolved.map((object) => {\n\t\tif (object.error || !object.data) {\n\t\t\tthrow new Error(`Failed to fetch object: ${object.error}`);\n\t\t}\n\t\tconst owner = object.data.owner;\n\t\tconst initialSharedVersion =\n\t\t\towner && typeof owner === 'object'\n\t\t\t\t? 'Shared' in owner\n\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t: 'ConsensusAddressOwner' in owner\n\t\t\t\t\t\t? owner.ConsensusAddressOwner.start_version\n\t\t\t\t\t\t: null\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tobjectId: object.data.objectId,\n\t\t\tdigest: object.data.digest,\n\t\t\tversion: object.data.version,\n\t\t\tinitialSharedVersion,\n\t\t};\n\t});\n\n\tconst objectsById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, objects[index]];\n\t\t}),\n\t);\n\n\tfor (const [index, input] of transactionData.inputs.entries()) {\n\t\tif (!input.UnresolvedObject) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet updated: CallArg | undefined;\n\t\tconst id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n\t\tconst object = objectsById.get(id);\n\n\t\tif (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n\t\t\tupdated = Inputs.SharedObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion!,\n\t\t\t\tmutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index),\n\t\t\t});\n\t\t} else if (isUsedAsReceiving(transactionData, index)) {\n\t\t\tupdated = Inputs.ReceivingRef(\n\t\t\t\t{\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t\t}!,\n\t\t\t);\n\t\t}\n\n\t\ttransactionData.inputs[transactionData.inputs.indexOf(input)] =\n\t\t\tupdated ??\n\t\t\tInputs.ObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t});\n\t}\n}\n\nasync function normalizeInputs(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tconst { inputs, commands } = transactionData;\n\tconst moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n\tconst moveFunctionsToResolve = new Set<string>();\n\n\tcommands.forEach((command) => {\n\t\t// Special case move call:\n\t\tif (command.MoveCall) {\n\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t// - If they don't, then this is good to go.\n\t\t\t// - If they do, then we need to fetch the normalized move module.\n\n\t\t\t// If we already know the argument types, we don't need to resolve them again\n\t\t\tif (command.MoveCall._argumentTypes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputs = command.MoveCall.arguments.map((arg) => {\n\t\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\t\treturn transactionData.inputs[arg.Input];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tconst needsResolution = inputs.some(\n\t\t\t\t(input) =>\n\t\t\t\t\tinput?.UnresolvedPure ||\n\t\t\t\t\t(input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== 'boolean'),\n\t\t\t);\n\n\t\t\tif (needsResolution) {\n\t\t\t\tconst functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n\t\t\t\tmoveFunctionsToResolve.add(functionName);\n\t\t\t\tmoveCallsToResolve.push(command.MoveCall);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n\tif (moveFunctionsToResolve.size > 0) {\n\t\tawait Promise.all(\n\t\t\t[...moveFunctionsToResolve].map(async (functionName) => {\n\t\t\t\tconst [packageId, moduleId, functionId] = functionName.split('::');\n\t\t\t\tconst def = await client.getNormalizedMoveFunction({\n\t\t\t\t\tpackage: packageId,\n\t\t\t\t\tmodule: moduleId,\n\t\t\t\t\tfunction: functionId,\n\t\t\t\t});\n\n\t\t\t\tmoveFunctionParameters.set(\n\t\t\t\t\tfunctionName,\n\t\t\t\t\tdef.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\tif (moveCallsToResolve.length) {\n\t\tawait Promise.all(\n\t\t\tmoveCallsToResolve.map(async (moveCall) => {\n\t\t\t\tconst parameters = moveFunctionParameters.get(\n\t\t\t\t\t`${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n\t\t\t\t);\n\n\t\t\t\tif (!parameters) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\tconst hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n\t\t\t\tconst params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n\n\t\t\t\tmoveCall._argumentTypes = params;\n\t\t\t}),\n\t\t);\n\t}\n\n\tcommands.forEach((command) => {\n\t\tif (!command.MoveCall) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst moveCall = command.MoveCall;\n\t\tconst fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n\t\tconst params = moveCall._argumentTypes;\n\n\t\tif (!params) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.length !== command.MoveCall.arguments.length) {\n\t\t\tthrow new Error(`Incorrect number of arguments for ${fnName}`);\n\t\t}\n\n\t\tparams.forEach((param, i) => {\n\t\t\tconst arg = moveCall.arguments[i];\n\t\t\tif (arg.$kind !== 'Input') return;\n\t\t\tconst input = inputs[arg.Input];\n\n\t\t\t// Skip if the input is already resolved\n\t\t\tif (!input.UnresolvedPure && !input.UnresolvedObject) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId!;\n\n\t\t\tconst schema = getPureBcsSchema(param.body);\n\t\t\tif (schema) {\n\t\t\t\targ.type = 'pure';\n\t\t\t\tinputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\targ.type = 'object';\n\t\t\tconst unresolvedObject: typeof input = input.UnresolvedPure\n\t\t\t\t? {\n\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: inputValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: input;\n\n\t\t\tinputs[arg.Input] = unresolvedObject;\n\t\t});\n\t});\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsMutable = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n\t\t}\n\n\t\tif (\n\t\t\ttx.$kind === 'MakeMoveVec' ||\n\t\t\ttx.$kind === 'MergeCoins' ||\n\t\t\ttx.$kind === 'SplitCoins' ||\n\t\t\ttx.$kind === 'TransferObjects'\n\t\t) {\n\t\t\tusedAsMutable = true;\n\t\t}\n\t});\n\n\treturn usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsReceiving = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n\t\t}\n\t});\n\n\treturn usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n\tif (typeof type.body !== 'object' || !('datatype' in type.body)) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\ttype.body.datatype.package === '0x2' &&\n\t\ttype.body.datatype.module === 'transfer' &&\n\t\ttype.body.datatype.type === 'Receiving'\n\t);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}