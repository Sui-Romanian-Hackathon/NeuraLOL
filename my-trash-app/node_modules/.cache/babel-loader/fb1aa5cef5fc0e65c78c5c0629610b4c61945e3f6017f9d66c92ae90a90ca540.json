{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _serializationPlugins, _buildPlugins, _intentResolvers, _inputSection, _commandSection, _availableResults, _pendingPromises, _added, _data, _Transaction_instances, fork_fn, addCommand_fn, addInput_fn, normalizeTransactionArgument_fn, resolveArgument_fn, prepareBuild_fn, runPlugins_fn, waitForPendingTasks_fn, sortCommandsAndInputs_fn;\nimport { fromBase64, isSerializedBcs } from \"@mysten/bcs\";\nimport { is, parse } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { Commands } from \"./Commands.js\";\nimport { ArgumentSchema, NormalizedCallArg, ObjectRefSchema, TransactionExpiration } from \"./data/internal.js\";\nimport { serializeV1TransactionData } from \"./data/v1.js\";\nimport { SerializedTransactionDataV2Schema } from \"./data/v2.js\";\nimport { Inputs } from \"./Inputs.js\";\nimport { needsTransactionResolution, resolveTransactionPlugin } from \"./resolve.js\";\nimport { createObjectMethods } from \"./object.js\";\nimport { createPure } from \"./pure.js\";\nimport { TransactionDataBuilder } from \"./TransactionData.js\";\nimport { getIdFromCallArg } from \"./utils.js\";\nimport { namedPackagesPlugin } from \"./plugins/NamedPackagesPlugin.js\";\nfunction createTransactionResult(index, length = Infinity) {\n  const baseResult = {\n    $kind: \"Result\",\n    get Result() {\n      return typeof index === \"function\" ? index() : index;\n    }\n  };\n  const nestedResults = [];\n  const nestedResultFor = resultIndex => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    $kind: \"NestedResult\",\n    get NestedResult() {\n      return [typeof index === \"function\" ? index() : index, resultIndex];\n    }\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\"The transaction result is a proxy, and does not support setting properties directly\");\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (i < length) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nconst TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nfunction isTransaction(obj) {\n  return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n}\nconst modulePluginRegistry = {\n  buildPlugins: /* @__PURE__ */new Map(),\n  serializationPlugins: /* @__PURE__ */new Map()\n};\nconst TRANSACTION_REGISTRY_KEY = Symbol.for(\"@mysten/transaction/registry\");\nfunction getGlobalPluginRegistry() {\n  try {\n    const target = globalThis;\n    if (!target[TRANSACTION_REGISTRY_KEY]) {\n      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n    }\n    return target[TRANSACTION_REGISTRY_KEY];\n  } catch {\n    return modulePluginRegistry;\n  }\n}\nconst _Transaction = class _Transaction {\n  constructor() {\n    __privateAdd(this, _Transaction_instances);\n    __privateAdd(this, _serializationPlugins);\n    __privateAdd(this, _buildPlugins);\n    __privateAdd(this, _intentResolvers, /* @__PURE__ */new Map());\n    __privateAdd(this, _inputSection, []);\n    __privateAdd(this, _commandSection, []);\n    __privateAdd(this, _availableResults, /* @__PURE__ */new Set());\n    __privateAdd(this, _pendingPromises, /* @__PURE__ */new Set());\n    __privateAdd(this, _added, /* @__PURE__ */new Map());\n    __privateAdd(this, _data);\n    /**\n     * Add a new object input to the transaction.\n     */\n    this.object = createObjectMethods(value => {\n      if (typeof value === \"function\") {\n        return this.object(this.add(value));\n      }\n      if (typeof value === \"object\" && is(ArgumentSchema, value)) {\n        return value;\n      }\n      const id = getIdFromCallArg(value);\n      const inserted = __privateGet(this, _data).inputs.find(i => id === getIdFromCallArg(i));\n      if (inserted?.Object?.SharedObject && typeof value === \"object\" && value.Object?.SharedObject) {\n        inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n      }\n      return inserted ? {\n        $kind: \"Input\",\n        Input: __privateGet(this, _data).inputs.indexOf(inserted),\n        type: \"object\"\n      } : __privateMethod(this, _Transaction_instances, addInput_fn).call(this, \"object\", typeof value === \"string\" ? {\n        $kind: \"UnresolvedObject\",\n        UnresolvedObject: {\n          objectId: normalizeSuiAddress(value)\n        }\n      } : value);\n    });\n    const globalPlugins = getGlobalPluginRegistry();\n    __privateSet(this, _data, new TransactionDataBuilder());\n    __privateSet(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);\n    __privateSet(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _Transaction();\n    __privateSet(tx, _data, TransactionDataBuilder.fromKindBytes(typeof serialized === \"string\" ? fromBase64(serialized) : serialized));\n    __privateSet(tx, _inputSection, __privateGet(tx, _data).inputs.slice());\n    __privateSet(tx, _commandSection, __privateGet(tx, _data).commands.slice());\n    __privateSet(tx, _availableResults, new Set(__privateGet(tx, _commandSection).map((_, i) => i)));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(transaction) {\n    const newTransaction = new _Transaction();\n    if (isTransaction(transaction)) {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.restore(transaction.getData()));\n    } else if (typeof transaction !== \"string\" || !transaction.startsWith(\"{\")) {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.fromBytes(typeof transaction === \"string\" ? fromBase64(transaction) : transaction));\n    } else {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));\n    }\n    __privateSet(newTransaction, _inputSection, __privateGet(newTransaction, _data).inputs.slice());\n    __privateSet(newTransaction, _commandSection, __privateGet(newTransaction, _data).commands.slice());\n    __privateSet(newTransaction, _availableResults, new Set(__privateGet(newTransaction, _commandSection).map((_, i) => i)));\n    return newTransaction;\n  }\n  static registerGlobalSerializationPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().serializationPlugins.set(stepOrStep, step ?? stepOrStep);\n  }\n  static unregisterGlobalSerializationPlugin(name) {\n    getGlobalPluginRegistry().serializationPlugins.delete(name);\n  }\n  static registerGlobalBuildPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().buildPlugins.set(stepOrStep, step ?? stepOrStep);\n  }\n  static unregisterGlobalBuildPlugin(name) {\n    getGlobalPluginRegistry().buildPlugins.delete(name);\n  }\n  addSerializationPlugin(step) {\n    __privateGet(this, _serializationPlugins).push(step);\n  }\n  addBuildPlugin(step) {\n    __privateGet(this, _buildPlugins).push(step);\n  }\n  addIntentResolver(intent, resolver) {\n    if (__privateGet(this, _intentResolvers).has(intent) && __privateGet(this, _intentResolvers).get(intent) !== resolver) {\n      throw new Error(`Intent resolver for ${intent} already exists`);\n    }\n    __privateGet(this, _intentResolvers).set(intent, resolver);\n  }\n  setSender(sender) {\n    __privateGet(this, _data).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _data).sender) {\n      __privateGet(this, _data).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _data).expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _data).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _data).gasConfig.budget = String(budget);\n  }\n  setGasBudgetIfNotSet(budget) {\n    if (__privateGet(this, _data).gasData.budget == null) {\n      __privateGet(this, _data).gasConfig.budget = String(budget);\n    }\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _data).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _data).gasConfig.payment = payments.map(payment => parse(ObjectRefSchema, payment));\n  }\n  /** @deprecated Use `getData()` instead. */\n  get blockData() {\n    return serializeV1TransactionData(__privateGet(this, _data).snapshot());\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  getData() {\n    return __privateGet(this, _data).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n  get pure() {\n    Object.defineProperty(this, \"pure\", {\n      enumerable: false,\n      value: createPure(value => {\n        if (isSerializedBcs(value)) {\n          return __privateMethod(this, _Transaction_instances, addInput_fn).call(this, \"pure\", {\n            $kind: \"Pure\",\n            Pure: {\n              bytes: value.toBase64()\n            }\n          });\n        }\n        return __privateMethod(this, _Transaction_instances, addInput_fn).call(this, \"pure\", is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : {\n          $kind: \"UnresolvedPure\",\n          UnresolvedPure: {\n            value\n          }\n        });\n      })\n    });\n    return this.pure;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return {\n      $kind: \"GasCoin\",\n      GasCoin: true\n    };\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef(...args) {\n    return this.object(Inputs.ObjectRef(...args));\n  }\n  /**\n   * Add a new receiving input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  receivingRef(...args) {\n    return this.object(Inputs.ReceivingRef(...args));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef(...args) {\n    return this.object(Inputs.SharedObjectRef(...args));\n  }\n  add(command) {\n    if (typeof command === \"function\") {\n      if (__privateGet(this, _added).has(command)) {\n        return __privateGet(this, _added).get(command);\n      }\n      const fork = __privateMethod(this, _Transaction_instances, fork_fn).call(this);\n      const result = command(fork);\n      if (!(result && typeof result === \"object\" && \"then\" in result)) {\n        __privateSet(this, _availableResults, __privateGet(fork, _availableResults));\n        __privateGet(this, _added).set(command, result);\n        return result;\n      }\n      const placeholder = __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, {\n        $kind: \"$Intent\",\n        $Intent: {\n          name: \"AsyncTransactionThunk\",\n          inputs: {},\n          data: {\n            resultIndex: __privateGet(this, _data).commands.length,\n            result: null\n          }\n        }\n      });\n      __privateGet(this, _pendingPromises).add(Promise.resolve(result).then(result2 => {\n        placeholder.$Intent.data.result = result2;\n      }));\n      const txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n      __privateGet(this, _added).set(command, txResult);\n      return txResult;\n    } else {\n      __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, command);\n    }\n    return createTransactionResult(__privateGet(this, _data).commands.length - 1);\n  }\n  // Method shorthands:\n  splitCoins(coin, amounts) {\n    const command = Commands.SplitCoins(typeof coin === \"string\" ? this.object(coin) : __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, coin), amounts.map(amount => typeof amount === \"number\" || typeof amount === \"bigint\" || typeof amount === \"string\" ? this.pure.u64(amount) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)));\n    __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, command);\n    return createTransactionResult(__privateGet(this, _data).commands.length - 1, amounts.length);\n  }\n  mergeCoins(destination, sources) {\n    return this.add(Commands.MergeCoins(this.object(destination), sources.map(src => this.object(src))));\n  }\n  publish({\n    modules,\n    dependencies\n  }) {\n    return this.add(Commands.Publish({\n      modules,\n      dependencies\n    }));\n  }\n  upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return this.add(Commands.Upgrade({\n      modules,\n      dependencies,\n      package: packageId,\n      ticket: this.object(ticket)\n    }));\n  }\n  moveCall({\n    arguments: args,\n    ...input\n  }) {\n    return this.add(Commands.MoveCall({\n      ...input,\n      arguments: args?.map(arg => __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))\n    }));\n  }\n  transferObjects(objects, address) {\n    return this.add(Commands.TransferObjects(objects.map(obj => this.object(obj)), typeof address === \"string\" ? this.pure.address(address) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)));\n  }\n  makeMoveVec({\n    type,\n    elements\n  }) {\n    return this.add(Commands.MakeMoveVec({\n      type,\n      elements: elements.map(obj => this.object(obj))\n    }));\n  }\n  /**\n   * @deprecated Use toJSON instead.\n   * For synchronous serialization, you can use `getData()`\n   * */\n  serialize() {\n    return JSON.stringify(serializeV1TransactionData(__privateGet(this, _data).snapshot()));\n  }\n  async toJSON(options = {}) {\n    await this.prepareForSerialization(options);\n    const fullyResolved = this.isFullyResolved();\n    return JSON.stringify(parse(SerializedTransactionDataV2Schema, fullyResolved ? {\n      ...__privateGet(this, _data).snapshot(),\n      digest: __privateGet(this, _data).getDigest()\n    } : __privateGet(this, _data).snapshot()), (_key, value) => typeof value === \"bigint\" ? value.toString() : value, 2);\n  }\n  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n  async sign(options) {\n    const {\n      signer,\n      ...buildOptions\n    } = options;\n    const bytes = await this.build(buildOptions);\n    return signer.signTransaction(bytes);\n  }\n  /**\n   *  Ensures that:\n   *  - All objects have been fully resolved to a specific version\n   *  - All pure inputs have been serialized to bytes\n   *  - All async thunks have been fully resolved\n   *  - All transaction intents have been resolved\n   * \t- The gas payment, budget, and price have been set\n   *  - The transaction sender has been set\n   *\n   *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n   */\n  isFullyResolved() {\n    if (!__privateGet(this, _data).sender) {\n      return false;\n    }\n    if (__privateGet(this, _pendingPromises).size > 0) {\n      return false;\n    }\n    if (__privateGet(this, _data).commands.some(cmd => cmd.$Intent)) {\n      return false;\n    }\n    if (needsTransactionResolution(__privateGet(this, _data), {})) {\n      return false;\n    }\n    return true;\n  }\n  /** Build the transaction to BCS bytes. */\n  async build(options = {}) {\n    await this.prepareForSerialization(options);\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).build({\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest(options = {}) {\n    await this.prepareForSerialization(options);\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).getDigest();\n  }\n  async prepareForSerialization(options) {\n    await __privateMethod(this, _Transaction_instances, waitForPendingTasks_fn).call(this);\n    __privateMethod(this, _Transaction_instances, sortCommandsAndInputs_fn).call(this);\n    const intents = /* @__PURE__ */new Set();\n    for (const command of __privateGet(this, _data).commands) {\n      if (command.$Intent) {\n        intents.add(command.$Intent.name);\n      }\n    }\n    const steps = [...__privateGet(this, _serializationPlugins)];\n    for (const intent of intents) {\n      if (options.supportedIntents?.includes(intent)) {\n        continue;\n      }\n      if (!__privateGet(this, _intentResolvers).has(intent)) {\n        throw new Error(`Missing intent resolver for ${intent}`);\n      }\n      steps.push(__privateGet(this, _intentResolvers).get(intent));\n    }\n    steps.push(namedPackagesPlugin());\n    await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);\n  }\n};\n_serializationPlugins = new WeakMap();\n_buildPlugins = new WeakMap();\n_intentResolvers = new WeakMap();\n_inputSection = new WeakMap();\n_commandSection = new WeakMap();\n_availableResults = new WeakMap();\n_pendingPromises = new WeakMap();\n_added = new WeakMap();\n_data = new WeakMap();\n_Transaction_instances = new WeakSet();\nfork_fn = function () {\n  const fork = new _Transaction();\n  __privateSet(fork, _data, __privateGet(this, _data));\n  __privateSet(fork, _serializationPlugins, __privateGet(this, _serializationPlugins));\n  __privateSet(fork, _buildPlugins, __privateGet(this, _buildPlugins));\n  __privateSet(fork, _intentResolvers, __privateGet(this, _intentResolvers));\n  __privateSet(fork, _pendingPromises, __privateGet(this, _pendingPromises));\n  __privateSet(fork, _availableResults, new Set(__privateGet(this, _availableResults)));\n  __privateSet(fork, _added, __privateGet(this, _added));\n  __privateGet(this, _inputSection).push(__privateGet(fork, _inputSection));\n  __privateGet(this, _commandSection).push(__privateGet(fork, _commandSection));\n  return fork;\n};\naddCommand_fn = function (command) {\n  const resultIndex = __privateGet(this, _data).commands.length;\n  __privateGet(this, _commandSection).push(command);\n  __privateGet(this, _availableResults).add(resultIndex);\n  __privateGet(this, _data).commands.push(command);\n  __privateGet(this, _data).mapCommandArguments(resultIndex, arg => {\n    if (arg.$kind === \"Result\" && !__privateGet(this, _availableResults).has(arg.Result)) {\n      throw new Error(`Result { Result: ${arg.Result} } is not available to use in the current transaction`);\n    }\n    if (arg.$kind === \"NestedResult\" && !__privateGet(this, _availableResults).has(arg.NestedResult[0])) {\n      throw new Error(`Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use in the current transaction`);\n    }\n    if (arg.$kind === \"Input\" && arg.Input >= __privateGet(this, _data).inputs.length) {\n      throw new Error(`Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`);\n    }\n    return arg;\n  });\n  return command;\n};\naddInput_fn = function (type, input) {\n  __privateGet(this, _inputSection).push(input);\n  return __privateGet(this, _data).addInput(type, input);\n};\nnormalizeTransactionArgument_fn = function (arg) {\n  if (isSerializedBcs(arg)) {\n    return this.pure(arg);\n  }\n  return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, arg);\n};\nresolveArgument_fn = function (arg) {\n  if (typeof arg === \"function\") {\n    const resolved = this.add(arg);\n    if (typeof resolved === \"function\") {\n      return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, resolved);\n    }\n    return parse(ArgumentSchema, resolved);\n  }\n  return parse(ArgumentSchema, arg);\n};\nprepareBuild_fn = async function (options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _data).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet(this, _buildPlugins), resolveTransactionPlugin], options);\n};\nrunPlugins_fn = async function (plugins, options) {\n  try {\n    const createNext = i => {\n      if (i >= plugins.length) {\n        return () => {};\n      }\n      const plugin = plugins[i];\n      return async () => {\n        const next = createNext(i + 1);\n        let calledNext = false;\n        let nextResolved = false;\n        await plugin(__privateGet(this, _data), options, async () => {\n          if (calledNext) {\n            throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n          }\n          calledNext = true;\n          await next();\n          nextResolved = true;\n        });\n        if (!calledNext) {\n          throw new Error(`next() was not called in TransactionPlugin ${i}`);\n        }\n        if (!nextResolved) {\n          throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n        }\n      };\n    };\n    await createNext(0)();\n  } finally {\n    __privateSet(this, _inputSection, __privateGet(this, _data).inputs.slice());\n    __privateSet(this, _commandSection, __privateGet(this, _data).commands.slice());\n  }\n};\nwaitForPendingTasks_fn = async function () {\n  while (__privateGet(this, _pendingPromises).size > 0) {\n    const newPromise = Promise.all(__privateGet(this, _pendingPromises));\n    __privateGet(this, _pendingPromises).clear();\n    __privateGet(this, _pendingPromises).add(newPromise);\n    await newPromise;\n    __privateGet(this, _pendingPromises).delete(newPromise);\n  }\n};\nsortCommandsAndInputs_fn = function () {\n  const unorderedCommands = __privateGet(this, _data).commands;\n  const unorderedInputs = __privateGet(this, _data).inputs;\n  const orderedCommands = __privateGet(this, _commandSection).flat(Infinity);\n  const orderedInputs = __privateGet(this, _inputSection).flat(Infinity);\n  if (orderedCommands.length !== unorderedCommands.length) {\n    throw new Error(\"Unexpected number of commands found in transaction data\");\n  }\n  if (orderedInputs.length !== unorderedInputs.length) {\n    throw new Error(\"Unexpected number of inputs found in transaction data\");\n  }\n  const filteredCommands = orderedCommands.filter(cmd => cmd.$Intent?.name !== \"AsyncTransactionThunk\");\n  __privateGet(this, _data).commands = filteredCommands;\n  __privateGet(this, _data).inputs = orderedInputs;\n  __privateSet(this, _commandSection, filteredCommands);\n  __privateSet(this, _inputSection, orderedInputs);\n  __privateSet(this, _availableResults, new Set(filteredCommands.map((_, i) => i)));\n  function getOriginalIndex(index) {\n    const command = unorderedCommands[index];\n    if (command.$Intent?.name === \"AsyncTransactionThunk\") {\n      const result = command.$Intent.data.result;\n      if (result == null) {\n        throw new Error(\"AsyncTransactionThunk has not been resolved\");\n      }\n      return getOriginalIndex(result.Result);\n    }\n    const updated = filteredCommands.indexOf(command);\n    if (updated === -1) {\n      throw new Error(\"Unable to find original index for command\");\n    }\n    return updated;\n  }\n  __privateGet(this, _data).mapArguments(arg => {\n    if (arg.$kind === \"Input\") {\n      const updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n      if (updated === -1) {\n        throw new Error(\"Input has not been resolved\");\n      }\n      return {\n        ...arg,\n        Input: updated\n      };\n    } else if (arg.$kind === \"Result\") {\n      const updated = getOriginalIndex(arg.Result);\n      return {\n        ...arg,\n        Result: updated\n      };\n    } else if (arg.$kind === \"NestedResult\") {\n      const updated = getOriginalIndex(arg.NestedResult[0]);\n      return {\n        ...arg,\n        NestedResult: [updated, arg.NestedResult[1]]\n      };\n    }\n    return arg;\n  });\n  for (const [i, cmd] of unorderedCommands.entries()) {\n    if (cmd.$Intent?.name === \"AsyncTransactionThunk\") {\n      try {\n        cmd.$Intent.data.resultIndex = getOriginalIndex(i);\n      } catch {}\n    }\n  }\n};\nlet Transaction = _Transaction;\nexport { Transaction, isTransaction };","map":{"version":3,"names":["_serializationPlugins","_buildPlugins","_intentResolvers","_inputSection","_commandSection","_availableResults","_pendingPromises","_added","_data","_Transaction_instances","fork_fn","addCommand_fn","addInput_fn","normalizeTransactionArgument_fn","resolveArgument_fn","prepareBuild_fn","runPlugins_fn","waitForPendingTasks_fn","sortCommandsAndInputs_fn","fromBase64","isSerializedBcs","is","parse","normalizeSuiAddress","Commands","ArgumentSchema","NormalizedCallArg","ObjectRefSchema","TransactionExpiration","serializeV1TransactionData","SerializedTransactionDataV2Schema","Inputs","needsTransactionResolution","resolveTransactionPlugin","createObjectMethods","createPure","TransactionDataBuilder","getIdFromCallArg","namedPackagesPlugin","createTransactionResult","index","length","Infinity","baseResult","$kind","Result","nestedResults","nestedResultFor","resultIndex","NestedResult","Proxy","set","Error","get","target","property","Reflect","Symbol","iterator","i","parseInt","Number","isNaN","TRANSACTION_BRAND","for","isTransaction","obj","modulePluginRegistry","buildPlugins","Map","serializationPlugins","TRANSACTION_REGISTRY_KEY","getGlobalPluginRegistry","globalThis","_Transaction","constructor","__privateAdd","Set","object","value","add","id","inserted","__privateGet","inputs","find","Object","SharedObject","mutable","Input","indexOf","type","__privateMethod","call","UnresolvedObject","objectId","globalPlugins","__privateSet","values","fromKind","serialized","tx","fromKindBytes","slice","commands","map","_","from","transaction","newTransaction","restore","getData","startsWith","fromBytes","JSON","registerGlobalSerializationPlugin","stepOrStep","step","unregisterGlobalSerializationPlugin","name","delete","registerGlobalBuildPlugin","unregisterGlobalBuildPlugin","addSerializationPlugin","push","addBuildPlugin","addIntentResolver","intent","resolver","has","setSender","sender","setSenderIfNotSet","setExpiration","expiration","setGasPrice","price","gasConfig","String","setGasBudget","budget","setGasBudgetIfNotSet","gasData","setGasOwner","owner","setGasPayment","payments","payment","blockData","snapshot","pure","defineProperty","enumerable","Pure","bytes","toBase64","Uint8Array","UnresolvedPure","gas","GasCoin","objectRef","args","ObjectRef","receivingRef","ReceivingRef","sharedObjectRef","SharedObjectRef","command","fork","result","placeholder","$Intent","data","Promise","resolve","then","result2","txResult","splitCoins","coin","amounts","SplitCoins","amount","u64","mergeCoins","destination","sources","MergeCoins","src","publish","modules","dependencies","Publish","upgrade","package","packageId","ticket","Upgrade","moveCall","arguments","input","MoveCall","arg","transferObjects","objects","address","TransferObjects","makeMoveVec","elements","MakeMoveVec","serialize","stringify","toJSON","options","prepareForSerialization","fullyResolved","isFullyResolved","digest","getDigest","_key","toString","sign","signer","buildOptions","build","signTransaction","size","some","cmd","onlyTransactionKind","intents","steps","supportedIntents","includes","WeakMap","WeakSet","mapCommandArguments","addInput","resolved","plugins","createNext","plugin","next","calledNext","nextResolved","newPromise","all","clear","unorderedCommands","unorderedInputs","orderedCommands","flat","orderedInputs","filteredCommands","filter","getOriginalIndex","updated","mapArguments","entries","Transaction"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/sui/src/transactions/Transaction.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromBase64, isSerializedBcs } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command, Argument, ObjectRef } from './data/internal.js';\nimport {\n\tArgumentSchema,\n\tNormalizedCallArg,\n\tObjectRefSchema,\n\tTransactionExpiration,\n} from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport { needsTransactionResolution, resolveTransactionPlugin } from './resolve.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './resolve.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\nimport { namedPackagesPlugin } from './plugins/NamedPackagesPlugin.js';\nimport type { ClientWithCoreApi } from '../experimental/core.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>\n\t| ((\n\t\t\ttx: Transaction,\n\t  ) => Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>)\n\t| AsyncTransactionThunk<TransactionResultArgument>;\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nexport type TransactionResultArgument =\n\t| Extract<Argument, { Result: unknown }>\n\t| readonly Extract<Argument, { NestedResult: unknown }>[];\n\nexport type AsyncTransactionThunk<\n\tT extends TransactionResultArgument | void = TransactionResultArgument | void,\n> = (tx: Transaction) => Promise<T | void>;\n\nfunction createTransactionResult(\n\tindex: number | (() => number),\n\tlength = Infinity,\n): TransactionResult {\n\tconst baseResult = {\n\t\t$kind: 'Result' as const,\n\t\tget Result() {\n\t\t\treturn typeof index === 'function' ? index() : index;\n\t\t},\n\t};\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tget NestedResult() {\n\t\t\t\treturn [typeof index === 'function' ? index() : index, resultIndex] as [number, number];\n\t\t\t},\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < length) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is TransactionLike {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tbuildPlugins: Map<string | Function, TransactionPlugin>;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tserializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n\tbuildPlugins: new Map(),\n\tserializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@mysten/transaction/registry');\nfunction getGlobalPluginRegistry() {\n\ttry {\n\t\tconst target = globalThis as {\n\t\t\t[TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n\t\t};\n\n\t\tif (!target[TRANSACTION_REGISTRY_KEY]) {\n\t\t\ttarget[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n\t\t}\n\n\t\treturn target[TRANSACTION_REGISTRY_KEY];\n\t} catch {\n\t\treturn modulePluginRegistry;\n\t}\n}\n\ntype InputSection = (CallArg | InputSection)[];\ntype CommandSection = (Command | CommandSection)[];\n\ntype TransactionLike = {\n\tgetData(): unknown;\n};\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[];\n\t#buildPlugins: TransactionPlugin[];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\t#inputSection: InputSection = [];\n\t#commandSection: CommandSection = [];\n\t#availableResults: Set<number> = new Set();\n\t#pendingPromises = new Set<Promise<unknown>>();\n\t#added = new Map<(...args: any[]) => unknown, unknown>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromBase64(serialized) : serialized,\n\t\t);\n\n\t\ttx.#inputSection = tx.#data.inputs.slice();\n\t\ttx.#commandSection = tx.#data.commands.slice();\n\t\ttx.#availableResults = new Set(tx.#commandSection.map((_, i) => i));\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | TransactionLike) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(\n\t\t\t\ttransaction.getData() as InferInput<typeof SerializedTransactionDataV2Schema>,\n\t\t\t);\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromBase64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\tnewTransaction.#inputSection = newTransaction.#data.inputs.slice();\n\t\tnewTransaction.#commandSection = newTransaction.#data.commands.slice();\n\t\tnewTransaction.#availableResults = new Set(newTransaction.#commandSection.map((_, i) => i));\n\n\t\treturn newTransaction;\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalSerializationPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.delete(name);\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalBuildPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().buildPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalBuildPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().buildPlugins.delete(name);\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\n\tsetGasBudgetIfNotSet(budget: number | bigint) {\n\t\tif (this.#data.gasData.budget == null) {\n\t\t\tthis.#data.gasConfig.budget = String(budget);\n\t\t}\n\t}\n\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRefSchema, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure<Argument>> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure<Argument>((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tconst globalPlugins = getGlobalPluginRegistry();\n\t\tthis.#data = new TransactionDataBuilder();\n\t\tthis.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n\t\tthis.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject: ReturnType<\n\t\ttypeof createObjectMethods<{ $kind: 'Input'; Input: number; type?: 'object' }>\n\t> = createObjectMethods(\n\t\t(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn this.object(this.add(value as (tx: Transaction) => TransactionObjectArgument));\n\t\t\t}\n\n\t\t\tif (typeof value === 'object' && is(ArgumentSchema, value)) {\n\t\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t\t}\n\n\t\t\tconst id = getIdFromCallArg(value);\n\n\t\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t\t// Upgrade shared object inputs to mutable if needed:\n\t\t\tif (\n\t\t\t\tinserted?.Object?.SharedObject &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\tvalue.Object?.SharedObject\n\t\t\t) {\n\t\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t\t}\n\n\t\t\treturn inserted\n\t\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t\t: this.#addInput(\n\t\t\t\t\t\t'object',\n\t\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: value,\n\t\t\t\t\t);\n\t\t},\n\t);\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t#fork() {\n\t\tconst fork = new Transaction();\n\n\t\tfork.#data = this.#data;\n\t\tfork.#serializationPlugins = this.#serializationPlugins;\n\t\tfork.#buildPlugins = this.#buildPlugins;\n\t\tfork.#intentResolvers = this.#intentResolvers;\n\t\tfork.#pendingPromises = this.#pendingPromises;\n\t\tfork.#availableResults = new Set(this.#availableResults);\n\t\tfork.#added = this.#added;\n\t\tthis.#inputSection.push(fork.#inputSection);\n\t\tthis.#commandSection.push(fork.#commandSection);\n\n\t\treturn fork;\n\t}\n\n\t/** Add a transaction to the transaction */\n\n\tadd<T extends Command>(command: T): TransactionResult;\n\tadd<T extends void | TransactionResultArgument | TransactionArgument | Command>(\n\t\tthunk: (tx: Transaction) => T,\n\t): T;\n\tadd<T extends TransactionResultArgument | void>(\n\t\tasyncTransactionThunk: AsyncTransactionThunk<T>,\n\t): T;\n\tadd(command: Command | AsyncTransactionThunk | ((tx: Transaction) => unknown)): unknown {\n\t\tif (typeof command === 'function') {\n\t\t\tif (this.#added.has(command)) {\n\t\t\t\treturn this.#added.get(command);\n\t\t\t}\n\n\t\t\tconst fork = this.#fork();\n\t\t\tconst result = command(fork);\n\n\t\t\tif (!(result && typeof result === 'object' && 'then' in result)) {\n\t\t\t\tthis.#availableResults = fork.#availableResults;\n\t\t\t\tthis.#added.set(command, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tconst placeholder = this.#addCommand({\n\t\t\t\t$kind: '$Intent',\n\t\t\t\t$Intent: {\n\t\t\t\t\tname: 'AsyncTransactionThunk',\n\t\t\t\t\tinputs: {},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tresultIndex: this.#data.commands.length,\n\t\t\t\t\t\tresult: null as TransactionResult | null,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.#pendingPromises.add(\n\t\t\t\tPromise.resolve(result as Promise<TransactionResult>).then((result) => {\n\t\t\t\t\tplaceholder.$Intent.data.result = result;\n\t\t\t\t}),\n\t\t\t);\n\t\t\tconst txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n\t\t\tthis.#added.set(command, txResult);\n\t\t\treturn txResult;\n\t\t} else {\n\t\t\tthis.#addCommand(command);\n\t\t}\n\n\t\treturn createTransactionResult(this.#data.commands.length - 1);\n\t}\n\n\t#addCommand<T extends Command>(command: T) {\n\t\tconst resultIndex = this.#data.commands.length;\n\t\tthis.#commandSection.push(command);\n\t\tthis.#availableResults.add(resultIndex);\n\t\tthis.#data.commands.push(command);\n\n\t\tthis.#data.mapCommandArguments(resultIndex, (arg) => {\n\t\t\tif (arg.$kind === 'Result' && !this.#availableResults.has(arg.Result)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { Result: ${arg.Result} } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'NestedResult' && !this.#availableResults.has(arg.NestedResult[0])) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'Input' && arg.Input >= this.#data.inputs.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\treturn command;\n\t}\n\n\t#addInput<T extends 'pure' | 'object'>(type: T, input: CallArg) {\n\t\tthis.#inputSection.push(input);\n\t\treturn this.#data.addInput(type, input);\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\tconst resolved = this.add(arg as never);\n\n\t\t\tif (typeof resolved === 'function') {\n\t\t\t\treturn this.#resolveArgument(resolved);\n\t\t\t}\n\n\t\t\treturn parse(ArgumentSchema, resolved);\n\t\t}\n\n\t\treturn parse(ArgumentSchema, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins<\n\t\tconst Amounts extends (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t>(coin: TransactionObjectArgument | string, amounts: Amounts) {\n\t\tconst command = Commands.SplitCoins(\n\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\tamounts.map((amount) =>\n\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t),\n\t\t);\n\t\tthis.#addCommand(command);\n\t\treturn createTransactionResult(this.#data.commands.length - 1, amounts.length) as Extract<\n\t\t\tArgument,\n\t\t\t{ Result: unknown }\n\t\t> & {\n\t\t\t[K in keyof Amounts]: Extract<Argument, { NestedResult: unknown }>;\n\t\t};\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tconst fullyResolved = this.isFullyResolved();\n\t\treturn JSON.stringify(\n\t\t\tparse(\n\t\t\t\tSerializedTransactionDataV2Schema,\n\t\t\t\tfullyResolved\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...this.#data.snapshot(),\n\t\t\t\t\t\t\tdigest: this.#data.getDigest(),\n\t\t\t\t\t\t}\n\t\t\t\t\t: this.#data.snapshot(),\n\t\t\t),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/**\n\t *  Ensures that:\n\t *  - All objects have been fully resolved to a specific version\n\t *  - All pure inputs have been serialized to bytes\n\t *  - All async thunks have been fully resolved\n\t *  - All transaction intents have been resolved\n\t * \t- The gas payment, budget, and price have been set\n\t *  - The transaction sender has been set\n\t *\n\t *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n\t */\n\tisFullyResolved() {\n\t\tif (!this.#data.sender) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#pendingPromises.size > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#data.commands.some((cmd) => cmd.$Intent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (needsTransactionResolution(this.#data, {})) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array<ArrayBuffer>> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: ClientWithCoreApi;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionPlugin], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\ttry {\n\t\t\tconst createNext = (i: number) => {\n\t\t\t\tif (i >= plugins.length) {\n\t\t\t\t\treturn () => {};\n\t\t\t\t}\n\t\t\t\tconst plugin = plugins[i];\n\n\t\t\t\treturn async () => {\n\t\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\t\tlet calledNext = false;\n\t\t\t\t\tlet nextResolved = false;\n\n\t\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\t\tawait next();\n\n\t\t\t\t\t\tnextResolved = true;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nextResolved) {\n\t\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tawait createNext(0)();\n\t\t} finally {\n\t\t\tthis.#inputSection = this.#data.inputs.slice();\n\t\t\tthis.#commandSection = this.#data.commands.slice();\n\t\t}\n\t}\n\n\tasync #waitForPendingTasks() {\n\t\twhile (this.#pendingPromises.size > 0) {\n\t\t\tconst newPromise = Promise.all(this.#pendingPromises);\n\t\t\tthis.#pendingPromises.clear();\n\t\t\tthis.#pendingPromises.add(newPromise);\n\t\t\tawait newPromise;\n\t\t\tthis.#pendingPromises.delete(newPromise);\n\t\t}\n\t}\n\n\t#sortCommandsAndInputs() {\n\t\tconst unorderedCommands = this.#data.commands;\n\t\tconst unorderedInputs = this.#data.inputs;\n\n\t\tconst orderedCommands = (this.#commandSection as Command[]).flat(Infinity);\n\t\tconst orderedInputs = (this.#inputSection as CallArg[]).flat(Infinity);\n\n\t\tif (orderedCommands.length !== unorderedCommands.length) {\n\t\t\tthrow new Error('Unexpected number of commands found in transaction data');\n\t\t}\n\n\t\tif (orderedInputs.length !== unorderedInputs.length) {\n\t\t\tthrow new Error('Unexpected number of inputs found in transaction data');\n\t\t}\n\n\t\tconst filteredCommands = orderedCommands.filter(\n\t\t\t(cmd) => cmd.$Intent?.name !== 'AsyncTransactionThunk',\n\t\t);\n\n\t\tthis.#data.commands = filteredCommands;\n\t\tthis.#data.inputs = orderedInputs;\n\t\tthis.#commandSection = filteredCommands;\n\t\tthis.#inputSection = orderedInputs;\n\t\tthis.#availableResults = new Set(filteredCommands.map((_, i) => i));\n\n\t\tfunction getOriginalIndex(index: number): number {\n\t\t\tconst command = unorderedCommands[index];\n\t\t\tif (command.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\tconst result = command.$Intent.data.result as TransactionResult | null;\n\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new Error('AsyncTransactionThunk has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn getOriginalIndex(result.Result);\n\t\t\t}\n\n\t\t\tconst updated = filteredCommands.indexOf(command);\n\n\t\t\tif (updated === -1) {\n\t\t\t\tthrow new Error('Unable to find original index for command');\n\t\t\t}\n\n\t\t\treturn updated;\n\t\t}\n\n\t\tthis.#data.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\tconst updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n\n\t\t\t\tif (updated === -1) {\n\t\t\t\t\tthrow new Error('Input has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn { ...arg, Input: updated };\n\t\t\t} else if (arg.$kind === 'Result') {\n\t\t\t\tconst updated = getOriginalIndex(arg.Result);\n\n\t\t\t\treturn { ...arg, Result: updated };\n\t\t\t} else if (arg.$kind === 'NestedResult') {\n\t\t\t\tconst updated = getOriginalIndex(arg.NestedResult[0]);\n\n\t\t\t\treturn { ...arg, NestedResult: [updated, arg.NestedResult[1]] };\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\tfor (const [i, cmd] of unorderedCommands.entries()) {\n\t\t\tif (cmd.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\ttry {\n\t\t\t\t\tcmd.$Intent.data.resultIndex = getOriginalIndex(i);\n\t\t\t\t} catch {\n\t\t\t\t\t// If async thunk did not return a result, this will error, but is safe to ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tawait this.#waitForPendingTasks();\n\t\tthis.#sortCommandsAndInputs();\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tsteps.push(namedPackagesPlugin());\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n"],"mappings":";;;;;;;;AAAA,IAAAA,qBAAA,EAAAC,aAAA,EAAAC,gBAAA,EAAAC,aAAA,EAAAC,eAAA,EAAAC,iBAAA,EAAAC,gBAAA,EAAAC,MAAA,EAAAC,KAAA,EAAAC,sBAAA,EAAAC,OAAA,EAAAC,aAAA,EAAAC,WAAA,EAAAC,+BAAA,EAAAC,kBAAA,EAAAC,eAAA,EAAAC,aAAA,EAAAC,sBAAA,EAAAC,wBAAA;AAIA,SAASC,UAAA,EAAYC,eAAA,QAAuB;AAE5C,SAASC,EAAA,EAAIC,KAAA,QAAa;AAG1B,SAASC,mBAAA,QAA2B;AAEpC,SAASC,QAAA,QAAgB;AAEzB,SACCC,cAAA,EACAC,iBAAA,EACAC,eAAA,EACAC,qBAAA,QACM;AACP,SAASC,0BAAA,QAAkC;AAC3C,SAASC,iCAAA,QAAyC;AAClD,SAASC,MAAA,QAAc;AACvB,SAASC,0BAAA,EAA4BC,wBAAA,QAAgC;AAMrE,SAASC,mBAAA,QAA2B;AACpC,SAASC,UAAA,QAAkB;AAC3B,SAASC,sBAAA,QAA8B;AACvC,SAASC,gBAAA,QAAwB;AACjC,SAASC,mBAAA,QAA2B;AAqBpC,SAASC,wBACRC,KAAA,EACAC,MAAA,GAASC,QAAA,EACW;EACpB,MAAMC,UAAA,GAAa;IAClBC,KAAA,EAAO;IACP,IAAIC,OAAA,EAAS;MACZ,OAAO,OAAOL,KAAA,KAAU,aAAaA,KAAA,CAAM,IAAIA,KAAA;IAChD;EACD;EAEA,MAAMM,aAAA,GAGA,EAAC;EACP,MAAMC,eAAA,GACLC,WAAA,IAKCF,aAAA,CAAAE,WAAA,MAAAF,aAAA,CAAAE,WAAA,IAA+B;IAC/BJ,KAAA,EAAO;IACP,IAAIK,aAAA,EAAe;MAClB,OAAO,CAAC,OAAOT,KAAA,KAAU,aAAaA,KAAA,CAAM,IAAIA,KAAA,EAAOQ,WAAW;IACnE;EACD;EAED,OAAO,IAAIE,KAAA,CAAMP,UAAA,EAAY;IAC5BQ,IAAA,EAAM;MACL,MAAM,IAAIC,KAAA,CACT,qFACD;IACD;IAAA;IAAA;IAAA;IAIAC,IAAIC,MAAA,EAAQC,QAAA,EAAU;MAErB,IAAIA,QAAA,IAAYD,MAAA,EAAQ;QACvB,OAAOE,OAAA,CAAQH,GAAA,CAAIC,MAAA,EAAQC,QAAQ;MACpC;MAGA,IAAIA,QAAA,KAAaE,MAAA,CAAOC,QAAA,EAAU;QACjC,OAAO,aAAa;UACnB,IAAIC,CAAA,GAAI;UACR,OAAOA,CAAA,GAAIlB,MAAA,EAAQ;YAClB,MAAMM,eAAA,CAAgBY,CAAC;YACvBA,CAAA;UACD;QACD;MACD;MAEA,IAAI,OAAOJ,QAAA,KAAa,UAAU;MAElC,MAAMP,WAAA,GAAcY,QAAA,CAASL,QAAA,EAAU,EAAE;MACzC,IAAIM,MAAA,CAAOC,KAAA,CAAMd,WAAW,KAAKA,WAAA,GAAc,GAAG;MAClD,OAAOD,eAAA,CAAgBC,WAAW;IACnC;EACD,CAAC;AACF;AAEA,MAAMe,iBAAA,GAAoBN,MAAA,CAAOO,GAAA,CAAI,qBAAqB;AAMnD,SAASC,cAAcC,GAAA,EAAsC;EACnE,OAAO,CAAC,CAACA,GAAA,IAAO,OAAOA,GAAA,KAAQ,YAAaA,GAAA,CAAYH,iBAAiB,MAAM;AAChF;AAWA,MAAMI,oBAAA,GAAkD;EACvDC,YAAA,EAAc,mBAAIC,GAAA,CAAI;EACtBC,oBAAA,EAAsB,mBAAID,GAAA,CAAI;AAC/B;AAEA,MAAME,wBAAA,GAA2Bd,MAAA,CAAOO,GAAA,CAAI,8BAA8B;AAC1E,SAASQ,wBAAA,EAA0B;EAClC,IAAI;IACH,MAAMlB,MAAA,GAASmB,UAAA;IAIf,IAAI,CAACnB,MAAA,CAAOiB,wBAAwB,GAAG;MACtCjB,MAAA,CAAOiB,wBAAwB,IAAIJ,oBAAA;IACpC;IAEA,OAAOb,MAAA,CAAOiB,wBAAwB;EACvC,QAAQ;IACP,OAAOJ,oBAAA;EACR;AACD;AAYO,MAAMO,YAAA,GAAN,MAAMA,YAAA,CAAY;EA4LxBC,YAAA,EAAc;IA5LRC,YAAA,OAAAnE,sBAAA;IACNmE,YAAA,OAAA5E,qBAAA;IACA4E,YAAA,OAAA3E,aAAA;IACA2E,YAAA,OAAA1E,gBAAA,EAAmB,mBAAImE,GAAA,CAA+B;IACtDO,YAAA,OAAAzE,aAAA,EAA8B,EAAC;IAC/ByE,YAAA,OAAAxE,eAAA,EAAkC,EAAC;IACnCwE,YAAA,OAAAvE,iBAAA,EAAiC,mBAAIwE,GAAA,CAAI;IACzCD,YAAA,OAAAtE,gBAAA,EAAmB,mBAAIuE,GAAA,CAAsB;IAC7CD,YAAA,OAAArE,MAAA,EAAS,mBAAI8D,GAAA,CAA0C;IAqIvDO,YAAA,OAAApE,KAAA;IA8DA;AAAA;AAAA;IAAA,KAAAsE,MAAA,GAEI5C,mBAAA,CACF6C,KAAA,IAAsF;MACtF,IAAI,OAAOA,KAAA,KAAU,YAAY;QAChC,OAAO,KAAKD,MAAA,CAAO,KAAKE,GAAA,CAAID,KAAuD,CAAC;MACrF;MAEA,IAAI,OAAOA,KAAA,KAAU,YAAY1D,EAAA,CAAGI,cAAA,EAAgBsD,KAAK,GAAG;QAC3D,OAAOA,KAAA;MACR;MAEA,MAAME,EAAA,GAAK5C,gBAAA,CAAiB0C,KAAK;MAEjC,MAAMG,QAAA,GAAWC,YAAA,OAAK3E,KAAA,EAAM4E,MAAA,CAAOC,IAAA,CAAM1B,CAAA,IAAMsB,EAAA,KAAO5C,gBAAA,CAAiBsB,CAAC,CAAC;MAGzE,IACCuB,QAAA,EAAUI,MAAA,EAAQC,YAAA,IAClB,OAAOR,KAAA,KAAU,YACjBA,KAAA,CAAMO,MAAA,EAAQC,YAAA,EACb;QACDL,QAAA,CAASI,MAAA,CAAOC,YAAA,CAAaC,OAAA,GAC5BN,QAAA,CAASI,MAAA,CAAOC,YAAA,CAAaC,OAAA,IAAWT,KAAA,CAAMO,MAAA,CAAOC,YAAA,CAAaC,OAAA;MACpE;MAEA,OAAON,QAAA,GACJ;QAAEtC,KAAA,EAAO;QAAS6C,KAAA,EAAON,YAAA,OAAK3E,KAAA,EAAM4E,MAAA,CAAOM,OAAA,CAAQR,QAAQ;QAAGS,IAAA,EAAM;MAAS,IAC7EC,eAAA,OAAKnF,sBAAA,EAAAG,WAAA,EAALiF,IAAA,OACA,UACA,OAAOd,KAAA,KAAU,WACd;QACAnC,KAAA,EAAO;QACPkD,gBAAA,EAAkB;UAAEC,QAAA,EAAUxE,mBAAA,CAAoBwD,KAAK;QAAE;MAC1D,IACCA,KAAA;IAEP,CACD;IApDC,MAAMiB,aAAA,GAAgBxB,uBAAA,CAAwB;IAC9CyB,YAAA,OAAKzF,KAAA,EAAQ,IAAI4B,sBAAA,CAAuB;IACxC6D,YAAA,OAAKhG,aAAA,EAAgB,CAAC,GAAG+F,aAAA,CAAc5B,YAAA,CAAa8B,MAAA,CAAO,CAAC;IAC5DD,YAAA,OAAKjG,qBAAA,EAAwB,CAAC,GAAGgG,aAAA,CAAc1B,oBAAA,CAAqB4B,MAAA,CAAO,CAAC;EAC7E;EAAA;AAAA;AAAA;AAAA;EAnLA,OAAOC,SAASC,UAAA,EAAiC;IAChD,MAAMC,EAAA,GAAK,IAAI3B,YAAA,CAAY;IAE3BuB,YAAA,CAAAI,EAAA,EAAG7F,KAAA,EAAQ4B,sBAAA,CAAuBkE,aAAA,CACjC,OAAOF,UAAA,KAAe,WAAWjF,UAAA,CAAWiF,UAAU,IAAIA,UAC3D;IAEAH,YAAA,CAAAI,EAAA,EAAGlG,aAAA,EAAgBgF,YAAA,CAAAkB,EAAA,EAAG7F,KAAA,EAAM4E,MAAA,CAAOmB,KAAA,CAAM;IACzCN,YAAA,CAAAI,EAAA,EAAGjG,eAAA,EAAkB+E,YAAA,CAAAkB,EAAA,EAAG7F,KAAA,EAAMgG,QAAA,CAASD,KAAA,CAAM;IAC7CN,YAAA,CAAAI,EAAA,EAAGhG,iBAAA,EAAoB,IAAIwE,GAAA,CAAIM,YAAA,CAAAkB,EAAA,EAAGjG,eAAA,EAAgBqG,GAAA,CAAI,CAACC,CAAA,EAAG/C,CAAA,KAAMA,CAAC,CAAC;IAElE,OAAO0C,EAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQA,OAAOM,KAAKC,WAAA,EAAoD;IAC/D,MAAMC,cAAA,GAAiB,IAAInC,YAAA,CAAY;IAEvC,IAAIT,aAAA,CAAc2C,WAAW,GAAG;MAC/BX,YAAA,CAAAY,cAAA,EAAerG,KAAA,EAAQ4B,sBAAA,CAAuB0E,OAAA,CAC7CF,WAAA,CAAYG,OAAA,CAAQ,CACrB;IACD,WAAW,OAAOH,WAAA,KAAgB,YAAY,CAACA,WAAA,CAAYI,UAAA,CAAW,GAAG,GAAG;MAC3Ef,YAAA,CAAAY,cAAA,EAAerG,KAAA,EAAQ4B,sBAAA,CAAuB6E,SAAA,CAC7C,OAAOL,WAAA,KAAgB,WAAWzF,UAAA,CAAWyF,WAAW,IAAIA,WAC7D;IACD,OAAO;MACNX,YAAA,CAAAY,cAAA,EAAerG,KAAA,EAAQ4B,sBAAA,CAAuB0E,OAAA,CAAQI,IAAA,CAAK5F,KAAA,CAAMsF,WAAW,CAAC;IAC9E;IAEAX,YAAA,CAAAY,cAAA,EAAe1G,aAAA,EAAgBgF,YAAA,CAAA0B,cAAA,EAAerG,KAAA,EAAM4E,MAAA,CAAOmB,KAAA,CAAM;IACjEN,YAAA,CAAAY,cAAA,EAAezG,eAAA,EAAkB+E,YAAA,CAAA0B,cAAA,EAAerG,KAAA,EAAMgG,QAAA,CAASD,KAAA,CAAM;IACrEN,YAAA,CAAAY,cAAA,EAAexG,iBAAA,EAAoB,IAAIwE,GAAA,CAAIM,YAAA,CAAA0B,cAAA,EAAezG,eAAA,EAAgBqG,GAAA,CAAI,CAACC,CAAA,EAAG/C,CAAA,KAAMA,CAAC,CAAC;IAE1F,OAAOkD,cAAA;EACR;EAKA,OAAOM,kCACNC,UAAA,EACAC,IAAA,EACC;IACD7C,uBAAA,CAAwB,EAAEF,oBAAA,CAAqBnB,GAAA,CAC9CiE,UAAA,EACAC,IAAA,IAASD,UACV;EACD;EAEA,OAAOE,oCAAoCC,IAAA,EAAc;IACxD/C,uBAAA,CAAwB,EAAEF,oBAAA,CAAqBkD,MAAA,CAAOD,IAAI;EAC3D;EAKA,OAAOE,0BACNL,UAAA,EACAC,IAAA,EACC;IACD7C,uBAAA,CAAwB,EAAEJ,YAAA,CAAajB,GAAA,CACtCiE,UAAA,EACAC,IAAA,IAASD,UACV;EACD;EAEA,OAAOM,4BAA4BH,IAAA,EAAc;IAChD/C,uBAAA,CAAwB,EAAEJ,YAAA,CAAaoD,MAAA,CAAOD,IAAI;EACnD;EAEAI,uBAAuBN,IAAA,EAAyB;IAC/ClC,YAAA,OAAKnF,qBAAA,EAAsB4H,IAAA,CAAKP,IAAI;EACrC;EAEAQ,eAAeR,IAAA,EAAyB;IACvClC,YAAA,OAAKlF,aAAA,EAAc2H,IAAA,CAAKP,IAAI;EAC7B;EAEAS,kBAAkBC,MAAA,EAAgBC,QAAA,EAA6B;IAC9D,IAAI7C,YAAA,OAAKjF,gBAAA,EAAiB+H,GAAA,CAAIF,MAAM,KAAK5C,YAAA,OAAKjF,gBAAA,EAAiBmD,GAAA,CAAI0E,MAAM,MAAMC,QAAA,EAAU;MACxF,MAAM,IAAI5E,KAAA,CAAM,uBAAuB2E,MAAM,iBAAiB;IAC/D;IAEA5C,YAAA,OAAKjF,gBAAA,EAAiBiD,GAAA,CAAI4E,MAAA,EAAQC,QAAQ;EAC3C;EAEAE,UAAUC,MAAA,EAAgB;IACzBhD,YAAA,OAAK3E,KAAA,EAAM2H,MAAA,GAASA,MAAA;EACrB;EAAA;AAAA;AAAA;AAAA;EAKAC,kBAAkBD,MAAA,EAAgB;IACjC,IAAI,CAAChD,YAAA,OAAK3E,KAAA,EAAM2H,MAAA,EAAQ;MACvBhD,YAAA,OAAK3E,KAAA,EAAM2H,MAAA,GAASA,MAAA;IACrB;EACD;EACAE,cAAcC,UAAA,EAA8D;IAC3EnD,YAAA,OAAK3E,KAAA,EAAM8H,UAAA,GAAaA,UAAA,GAAahH,KAAA,CAAMM,qBAAA,EAAuB0G,UAAU,IAAI;EACjF;EACAC,YAAYC,KAAA,EAAwB;IACnCrD,YAAA,OAAK3E,KAAA,EAAMiI,SAAA,CAAUD,KAAA,GAAQE,MAAA,CAAOF,KAAK;EAC1C;EACAG,aAAaC,MAAA,EAAyB;IACrCzD,YAAA,OAAK3E,KAAA,EAAMiI,SAAA,CAAUG,MAAA,GAASF,MAAA,CAAOE,MAAM;EAC5C;EAEAC,qBAAqBD,MAAA,EAAyB;IAC7C,IAAIzD,YAAA,OAAK3E,KAAA,EAAMsI,OAAA,CAAQF,MAAA,IAAU,MAAM;MACtCzD,YAAA,OAAK3E,KAAA,EAAMiI,SAAA,CAAUG,MAAA,GAASF,MAAA,CAAOE,MAAM;IAC5C;EACD;EAEAG,YAAYC,KAAA,EAAe;IAC1B7D,YAAA,OAAK3E,KAAA,EAAMiI,SAAA,CAAUO,KAAA,GAAQA,KAAA;EAC9B;EACAC,cAAcC,QAAA,EAAuB;IACpC/D,YAAA,OAAK3E,KAAA,EAAMiI,SAAA,CAAUU,OAAA,GAAUD,QAAA,CAASzC,GAAA,CAAK0C,OAAA,IAAY7H,KAAA,CAAMK,eAAA,EAAiBwH,OAAO,CAAC;EACzF;EAAA;EAKA,IAAIC,UAAA,EAAY;IACf,OAAOvH,0BAAA,CAA2BsD,YAAA,OAAK3E,KAAA,EAAM6I,QAAA,CAAS,CAAC;EACxD;EAAA;EAGAtC,QAAA,EAAU;IACT,OAAO5B,YAAA,OAAK3E,KAAA,EAAM6I,QAAA,CAAS;EAC5B;EAAA;EAAA;EAIA,KAAKtF,iBAAiB,IAAI;IACzB,OAAO;EACR;EAAA;EAGA,IAAIuF,KAAA,EAAgD;IACnDhE,MAAA,CAAOiE,cAAA,CAAe,MAAM,QAAQ;MACnCC,UAAA,EAAY;MACZzE,KAAA,EAAO5C,UAAA,CAAsB4C,KAAA,IAAoB;QAChD,IAAI3D,eAAA,CAAgB2D,KAAK,GAAG;UAC3B,OAAOa,eAAA,OAAKnF,sBAAA,EAAAG,WAAA,EAALiF,IAAA,OAAe,QAAQ;YAC7BjD,KAAA,EAAO;YACP6G,IAAA,EAAM;cACLC,KAAA,EAAO3E,KAAA,CAAM4E,QAAA,CAAS;YACvB;UACD;QACD;QAGA,OAAO/D,eAAA,OAAKnF,sBAAA,EAAAG,WAAA,EAALiF,IAAA,OACN,QACAxE,EAAA,CAAGK,iBAAA,EAAmBqD,KAAK,IACxBzD,KAAA,CAAMI,iBAAA,EAAmBqD,KAAK,IAC9BA,KAAA,YAAiB6E,UAAA,GAChB7H,MAAA,CAAO0H,IAAA,CAAK1E,KAAK,IACjB;UAAEnC,KAAA,EAAO;UAAkBiH,cAAA,EAAgB;YAAE9E;UAAM;QAAE;MAE3D,CAAC;IACF,CAAC;IAED,OAAO,KAAKuE,IAAA;EACb;EAAA;EAUA,IAAIQ,IAAA,EAAM;IACT,OAAO;MAAElH,KAAA,EAAO;MAAoBmH,OAAA,EAAS;IAAc;EAC5D;EAAA;AAAA;AAAA;AAAA;EAiDAC,UAAA,GAAaC,IAAA,EAAgD;IAC5D,OAAO,KAAKnF,MAAA,CAAO/C,MAAA,CAAOmI,SAAA,CAAU,GAAGD,IAAI,CAAC;EAC7C;EAAA;AAAA;AAAA;AAAA;EAMAE,aAAA,GAAgBF,IAAA,EAAmD;IAClE,OAAO,KAAKnF,MAAA,CAAO/C,MAAA,CAAOqI,YAAA,CAAa,GAAGH,IAAI,CAAC;EAChD;EAAA;AAAA;AAAA;AAAA;EAMAI,gBAAA,GAAmBJ,IAAA,EAAsD;IACxE,OAAO,KAAKnF,MAAA,CAAO/C,MAAA,CAAOuI,eAAA,CAAgB,GAAGL,IAAI,CAAC;EACnD;EA2BAjF,IAAIuF,OAAA,EAAoF;IACvF,IAAI,OAAOA,OAAA,KAAY,YAAY;MAClC,IAAIpF,YAAA,OAAK5E,MAAA,EAAO0H,GAAA,CAAIsC,OAAO,GAAG;QAC7B,OAAOpF,YAAA,OAAK5E,MAAA,EAAO8C,GAAA,CAAIkH,OAAO;MAC/B;MAEA,MAAMC,IAAA,GAAO5E,eAAA,OAAKnF,sBAAA,EAAAC,OAAA,EAALmF,IAAA;MACb,MAAM4E,MAAA,GAASF,OAAA,CAAQC,IAAI;MAE3B,IAAI,EAAEC,MAAA,IAAU,OAAOA,MAAA,KAAW,YAAY,UAAUA,MAAA,GAAS;QAChExE,YAAA,OAAK5F,iBAAA,EAAoB8E,YAAA,CAAAqF,IAAA,EAAKnK,iBAAA;QAC9B8E,YAAA,OAAK5E,MAAA,EAAO4C,GAAA,CAAIoH,OAAA,EAASE,MAAM;QAC/B,OAAOA,MAAA;MACR;MAEA,MAAMC,WAAA,GAAc9E,eAAA,OAAKnF,sBAAA,EAAAE,aAAA,EAALkF,IAAA,OAAiB;QACpCjD,KAAA,EAAO;QACP+H,OAAA,EAAS;UACRpD,IAAA,EAAM;UACNnC,MAAA,EAAQ,CAAC;UACTwF,IAAA,EAAM;YACL5H,WAAA,EAAamC,YAAA,OAAK3E,KAAA,EAAMgG,QAAA,CAAS/D,MAAA;YACjCgI,MAAA,EAAQ;UACT;QACD;MACD;MAEAtF,YAAA,OAAK7E,gBAAA,EAAiB0E,GAAA,CACrB6F,OAAA,CAAQC,OAAA,CAAQL,MAAoC,EAAEM,IAAA,CAAMC,OAAA,IAAW;QACtEN,WAAA,CAAYC,OAAA,CAAQC,IAAA,CAAKH,MAAA,GAASO,OAAA;MACnC,CAAC,CACF;MACA,MAAMC,QAAA,GAAW1I,uBAAA,CAAwB,MAAMmI,WAAA,CAAYC,OAAA,CAAQC,IAAA,CAAK5H,WAAW;MACnFmC,YAAA,OAAK5E,MAAA,EAAO4C,GAAA,CAAIoH,OAAA,EAASU,QAAQ;MACjC,OAAOA,QAAA;IACR,OAAO;MACNrF,eAAA,OAAKnF,sBAAA,EAAAE,aAAA,EAALkF,IAAA,OAAiB0E,OAAA;IAClB;IAEA,OAAOhI,uBAAA,CAAwB4C,YAAA,OAAK3E,KAAA,EAAMgG,QAAA,CAAS/D,MAAA,GAAS,CAAC;EAC9D;EAAA;EA8DAyI,WAEEC,IAAA,EAA0CC,OAAA,EAAkB;IAC7D,MAAMb,OAAA,GAAU/I,QAAA,CAAS6J,UAAA,CACxB,OAAOF,IAAA,KAAS,WAAW,KAAKrG,MAAA,CAAOqG,IAAI,IAAIvF,eAAA,OAAKnF,sBAAA,EAAAK,kBAAA,EAAL+E,IAAA,OAAsBsF,IAAA,GACrEC,OAAA,CAAQ3E,GAAA,CAAK6E,MAAA,IACZ,OAAOA,MAAA,KAAW,YAAY,OAAOA,MAAA,KAAW,YAAY,OAAOA,MAAA,KAAW,WAC3E,KAAKhC,IAAA,CAAKiC,GAAA,CAAID,MAAM,IACpB1F,eAAA,OAAKnF,sBAAA,EAAAI,+BAAA,EAALgF,IAAA,OAAmCyF,MAAA,CACvC,CACD;IACA1F,eAAA,OAAKnF,sBAAA,EAAAE,aAAA,EAALkF,IAAA,OAAiB0E,OAAA;IACjB,OAAOhI,uBAAA,CAAwB4C,YAAA,OAAK3E,KAAA,EAAMgG,QAAA,CAAS/D,MAAA,GAAS,GAAG2I,OAAA,CAAQ3I,MAAM;EAM9E;EACA+I,WACCC,WAAA,EACAC,OAAA,EACC;IACD,OAAO,KAAK1G,GAAA,CACXxD,QAAA,CAASmK,UAAA,CACR,KAAK7G,MAAA,CAAO2G,WAAW,GACvBC,OAAA,CAAQjF,GAAA,CAAKmF,GAAA,IAAQ,KAAK9G,MAAA,CAAO8G,GAAG,CAAC,CACtC,CACD;EACD;EACAC,QAAQ;IAAEC,OAAA;IAASC;EAAa,GAA+D;IAC9F,OAAO,KAAK/G,GAAA,CACXxD,QAAA,CAASwK,OAAA,CAAQ;MAChBF,OAAA;MACAC;IACD,CAAC,CACF;EACD;EACAE,QAAQ;IACPH,OAAA;IACAC,YAAA;IACAG,OAAA,EAASC,SAAA;IACTC;EACD,GAKG;IACF,OAAO,KAAKpH,GAAA,CACXxD,QAAA,CAAS6K,OAAA,CAAQ;MAChBP,OAAA;MACAC,YAAA;MACAG,OAAA,EAASC,SAAA;MACTC,MAAA,EAAQ,KAAKtH,MAAA,CAAOsH,MAAM;IAC3B,CAAC,CACF;EACD;EACAE,SAAS;IACRC,SAAA,EAAWtC,IAAA;IACX,GAAGuC;EACJ,GAYM;IACL,OAAO,KAAKxH,GAAA,CACXxD,QAAA,CAASiL,QAAA,CAAS;MACjB,GAAGD,KAAA;MACHD,SAAA,EAAWtC,IAAA,EAAMxD,GAAA,CAAKiG,GAAA,IAAQ9G,eAAA,OAAKnF,sBAAA,EAAAI,+BAAA,EAALgF,IAAA,OAAmC6G,GAAA,CAAI;IACtE,CAA4C,CAC7C;EACD;EACAC,gBACCC,OAAA,EACAC,OAAA,EACC;IACD,OAAO,KAAK7H,GAAA,CACXxD,QAAA,CAASsL,eAAA,CACRF,OAAA,CAAQnG,GAAA,CAAKvC,GAAA,IAAQ,KAAKY,MAAA,CAAOZ,GAAG,CAAC,GACrC,OAAO2I,OAAA,KAAY,WAChB,KAAKvD,IAAA,CAAKuD,OAAA,CAAQA,OAAO,IACzBjH,eAAA,OAAKnF,sBAAA,EAAAI,+BAAA,EAALgF,IAAA,OAAmCgH,OAAA,CACvC,CACD;EACD;EACAE,YAAY;IACXpH,IAAA;IACAqH;EACD,GAGG;IACF,OAAO,KAAKhI,GAAA,CACXxD,QAAA,CAASyL,WAAA,CAAY;MACpBtH,IAAA;MACAqH,QAAA,EAAUA,QAAA,CAASvG,GAAA,CAAKvC,GAAA,IAAQ,KAAKY,MAAA,CAAOZ,GAAG,CAAC;IACjD,CAAC,CACF;EACD;EAAA;AAAA;AAAA;AAAA;EAMAgJ,UAAA,EAAY;IACX,OAAOhG,IAAA,CAAKiG,SAAA,CAAUtL,0BAAA,CAA2BsD,YAAA,OAAK3E,KAAA,EAAM6I,QAAA,CAAS,CAAC,CAAC;EACxE;EAEA,MAAM+D,OAAOC,OAAA,GAAuC,CAAC,GAAoB;IACxE,MAAM,KAAKC,uBAAA,CAAwBD,OAAO;IAC1C,MAAME,aAAA,GAAgB,KAAKC,eAAA,CAAgB;IAC3C,OAAOtG,IAAA,CAAKiG,SAAA,CACX7L,KAAA,CACCQ,iCAAA,EACAyL,aAAA,GACG;MACA,GAAGpI,YAAA,OAAK3E,KAAA,EAAM6I,QAAA,CAAS;MACvBoE,MAAA,EAAQtI,YAAA,OAAK3E,KAAA,EAAMkN,SAAA,CAAU;IAC9B,IACCvI,YAAA,OAAK3E,KAAA,EAAM6I,QAAA,CAAS,CACxB,GACA,CAACsE,IAAA,EAAM5I,KAAA,KAAW,OAAOA,KAAA,KAAU,WAAWA,KAAA,CAAM6I,QAAA,CAAS,IAAI7I,KAAA,EACjE,CACD;EACD;EAAA;EAGA,MAAM8I,KAAKR,OAAA,EAAmD;IAC7D,MAAM;MAAES,MAAA;MAAQ,GAAGC;IAAa,IAAIV,OAAA;IACpC,MAAM3D,KAAA,GAAQ,MAAM,KAAKsE,KAAA,CAAMD,YAAY;IAC3C,OAAOD,MAAA,CAAOG,eAAA,CAAgBvE,KAAK;EACpC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAaA8D,gBAAA,EAAkB;IACjB,IAAI,CAACrI,YAAA,OAAK3E,KAAA,EAAM2H,MAAA,EAAQ;MACvB,OAAO;IACR;IAEA,IAAIhD,YAAA,OAAK7E,gBAAA,EAAiB4N,IAAA,GAAO,GAAG;MACnC,OAAO;IACR;IAEA,IAAI/I,YAAA,OAAK3E,KAAA,EAAMgG,QAAA,CAAS2H,IAAA,CAAMC,GAAA,IAAQA,GAAA,CAAIzD,OAAO,GAAG;MACnD,OAAO;IACR;IAEA,IAAI3I,0BAAA,CAA2BmD,YAAA,OAAK3E,KAAA,GAAO,CAAC,CAAC,GAAG;MAC/C,OAAO;IACR;IAEA,OAAO;EACR;EAAA;EAGA,MAAMwN,MAAMX,OAAA,GAAmC,CAAC,GAAqC;IACpF,MAAM,KAAKC,uBAAA,CAAwBD,OAAO;IAC1C,MAAMzH,eAAA,OAAKnF,sBAAA,EAAAM,eAAA,EAAL8E,IAAA,OAAmBwH,OAAA;IACzB,OAAOlI,YAAA,OAAK3E,KAAA,EAAMwN,KAAA,CAAM;MACvBK,mBAAA,EAAqBhB,OAAA,CAAQgB;IAC9B,CAAC;EACF;EAAA;EAGA,MAAMX,UACLL,OAAA,GAEI,CAAC,GACa;IAClB,MAAM,KAAKC,uBAAA,CAAwBD,OAAO;IAC1C,MAAMzH,eAAA,OAAKnF,sBAAA,EAAAM,eAAA,EAAL8E,IAAA,OAAmBwH,OAAA;IACzB,OAAOlI,YAAA,OAAK3E,KAAA,EAAMkN,SAAA,CAAU;EAC7B;EAiJA,MAAMJ,wBAAwBD,OAAA,EAAsC;IACnE,MAAMzH,eAAA,OAAKnF,sBAAA,EAAAQ,sBAAA,EAAL4E,IAAA;IACND,eAAA,OAAKnF,sBAAA,EAAAS,wBAAA,EAAL2E,IAAA;IACA,MAAMyI,OAAA,GAAU,mBAAIzJ,GAAA,CAAY;IAChC,WAAW0F,OAAA,IAAWpF,YAAA,OAAK3E,KAAA,EAAMgG,QAAA,EAAU;MAC1C,IAAI+D,OAAA,CAAQI,OAAA,EAAS;QACpB2D,OAAA,CAAQtJ,GAAA,CAAIuF,OAAA,CAAQI,OAAA,CAAQpD,IAAI;MACjC;IACD;IAEA,MAAMgH,KAAA,GAAQ,CAAC,GAAGpJ,YAAA,OAAKnF,qBAAA,CAAqB;IAE5C,WAAW+H,MAAA,IAAUuG,OAAA,EAAS;MAC7B,IAAIjB,OAAA,CAAQmB,gBAAA,EAAkBC,QAAA,CAAS1G,MAAM,GAAG;QAC/C;MACD;MAEA,IAAI,CAAC5C,YAAA,OAAKjF,gBAAA,EAAiB+H,GAAA,CAAIF,MAAM,GAAG;QACvC,MAAM,IAAI3E,KAAA,CAAM,+BAA+B2E,MAAM,EAAE;MACxD;MAEAwG,KAAA,CAAM3G,IAAA,CAAKzC,YAAA,OAAKjF,gBAAA,EAAiBmD,GAAA,CAAI0E,MAAM,CAAE;IAC9C;IAEAwG,KAAA,CAAM3G,IAAA,CAAKtF,mBAAA,CAAoB,CAAC;IAEhC,MAAMsD,eAAA,OAAKnF,sBAAA,EAAAO,aAAA,EAAL6E,IAAA,OAAiB0I,KAAA,EAAOlB,OAAA;EAC/B;AACD;AArvBCrN,qBAAA,OAAA0O,OAAA;AACAzO,aAAA,OAAAyO,OAAA;AACAxO,gBAAA,OAAAwO,OAAA;AACAvO,aAAA,OAAAuO,OAAA;AACAtO,eAAA,OAAAsO,OAAA;AACArO,iBAAA,OAAAqO,OAAA;AACApO,gBAAA,OAAAoO,OAAA;AACAnO,MAAA,OAAAmO,OAAA;AAqIAlO,KAAA,OAAAkO,OAAA;AA7IMjO,sBAAA,OAAAkO,OAAA;AA2QNjO,OAAA,GAAK,SAAAA,CAAA,EAAG;EACP,MAAM8J,IAAA,GAAO,IAAI9F,YAAA,CAAY;EAE7BuB,YAAA,CAAAuE,IAAA,EAAKhK,KAAA,EAAQ2E,YAAA,OAAK3E,KAAA;EAClByF,YAAA,CAAAuE,IAAA,EAAKxK,qBAAA,EAAwBmF,YAAA,OAAKnF,qBAAA;EAClCiG,YAAA,CAAAuE,IAAA,EAAKvK,aAAA,EAAgBkF,YAAA,OAAKlF,aAAA;EAC1BgG,YAAA,CAAAuE,IAAA,EAAKtK,gBAAA,EAAmBiF,YAAA,OAAKjF,gBAAA;EAC7B+F,YAAA,CAAAuE,IAAA,EAAKlK,gBAAA,EAAmB6E,YAAA,OAAK7E,gBAAA;EAC7B2F,YAAA,CAAAuE,IAAA,EAAKnK,iBAAA,EAAoB,IAAIwE,GAAA,CAAIM,YAAA,OAAK9E,iBAAA,CAAiB;EACvD4F,YAAA,CAAAuE,IAAA,EAAKjK,MAAA,EAAS4E,YAAA,OAAK5E,MAAA;EACnB4E,YAAA,OAAKhF,aAAA,EAAcyH,IAAA,CAAKzC,YAAA,CAAAqF,IAAA,EAAKrK,aAAA,CAAa;EAC1CgF,YAAA,OAAK/E,eAAA,EAAgBwH,IAAA,CAAKzC,YAAA,CAAAqF,IAAA,EAAKpK,eAAA,CAAe;EAE9C,OAAOoK,IAAA;AACR;AAqDA7J,aAAA,GAA8B,SAAAA,CAAC4J,OAAA,EAAY;EAC1C,MAAMvH,WAAA,GAAcmC,YAAA,OAAK3E,KAAA,EAAMgG,QAAA,CAAS/D,MAAA;EACxC0C,YAAA,OAAK/E,eAAA,EAAgBwH,IAAA,CAAK2C,OAAO;EACjCpF,YAAA,OAAK9E,iBAAA,EAAkB2E,GAAA,CAAIhC,WAAW;EACtCmC,YAAA,OAAK3E,KAAA,EAAMgG,QAAA,CAASoB,IAAA,CAAK2C,OAAO;EAEhCpF,YAAA,OAAK3E,KAAA,EAAMoO,mBAAA,CAAoB5L,WAAA,EAAc0J,GAAA,IAAQ;IACpD,IAAIA,GAAA,CAAI9J,KAAA,KAAU,YAAY,CAACuC,YAAA,OAAK9E,iBAAA,EAAkB4H,GAAA,CAAIyE,GAAA,CAAI7J,MAAM,GAAG;MACtE,MAAM,IAAIO,KAAA,CACT,oBAAoBsJ,GAAA,CAAI7J,MAAM,uDAC/B;IACD;IAEA,IAAI6J,GAAA,CAAI9J,KAAA,KAAU,kBAAkB,CAACuC,YAAA,OAAK9E,iBAAA,EAAkB4H,GAAA,CAAIyE,GAAA,CAAIzJ,YAAA,CAAa,CAAC,CAAC,GAAG;MACrF,MAAM,IAAIG,KAAA,CACT,2BAA2BsJ,GAAA,CAAIzJ,YAAA,CAAa,CAAC,CAAC,KAAKyJ,GAAA,CAAIzJ,YAAA,CAAa,CAAC,CAAC,wDACvE;IACD;IAEA,IAAIyJ,GAAA,CAAI9J,KAAA,KAAU,WAAW8J,GAAA,CAAIjH,KAAA,IAASN,YAAA,OAAK3E,KAAA,EAAM4E,MAAA,CAAO3C,MAAA,EAAQ;MACnE,MAAM,IAAIW,KAAA,CACT,kBAAkBsJ,GAAA,CAAIjH,KAAK,uEAC5B;IACD;IAEA,OAAOiH,GAAA;EACR,CAAC;EAED,OAAOnC,OAAA;AACR;AAEA3J,WAAA,GAAsC,SAAAA,CAAC+E,IAAA,EAAS6G,KAAA,EAAgB;EAC/DrH,YAAA,OAAKhF,aAAA,EAAcyH,IAAA,CAAK4E,KAAK;EAC7B,OAAOrH,YAAA,OAAK3E,KAAA,EAAMqO,QAAA,CAASlJ,IAAA,EAAM6G,KAAK;AACvC;AAEA3L,+BAAA,GAA6B,SAAAA,CAAC6L,GAAA,EAA+C;EAC5E,IAAItL,eAAA,CAAgBsL,GAAG,GAAG;IACzB,OAAO,KAAKpD,IAAA,CAAKoD,GAAG;EACrB;EAEA,OAAO9G,eAAA,OAAKnF,sBAAA,EAAAK,kBAAA,EAAL+E,IAAA,OAAsB6G,GAAA;AAC9B;AAEA5L,kBAAA,GAAgB,SAAAA,CAAC4L,GAAA,EAAoC;EACpD,IAAI,OAAOA,GAAA,KAAQ,YAAY;IAC9B,MAAMoC,QAAA,GAAW,KAAK9J,GAAA,CAAI0H,GAAY;IAEtC,IAAI,OAAOoC,QAAA,KAAa,YAAY;MACnC,OAAOlJ,eAAA,OAAKnF,sBAAA,EAAAK,kBAAA,EAAL+E,IAAA,OAAsBiJ,QAAA;IAC9B;IAEA,OAAOxN,KAAA,CAAMG,cAAA,EAAgBqN,QAAQ;EACtC;EAEA,OAAOxN,KAAA,CAAMG,cAAA,EAAgBiL,GAAG;AACjC;AAyMM3L,eAAA,GAAa,eAAAA,CAACsM,OAAA,EAAkC;EACrD,IAAI,CAACA,OAAA,CAAQgB,mBAAA,IAAuB,CAAClJ,YAAA,OAAK3E,KAAA,EAAM2H,MAAA,EAAQ;IACvD,MAAM,IAAI/E,KAAA,CAAM,4BAA4B;EAC7C;EAEA,MAAMwC,eAAA,OAAKnF,sBAAA,EAAAO,aAAA,EAAL6E,IAAA,OAAiB,CAAC,GAAGV,YAAA,OAAKlF,aAAA,GAAegC,wBAAwB,GAAGoL,OAAA;AAC3E;AAEMrM,aAAA,GAAW,eAAAA,CAAC+N,OAAA,EAA8B1B,OAAA,EAAsC;EACrF,IAAI;IACH,MAAM2B,UAAA,GAAcrL,CAAA,IAAc;MACjC,IAAIA,CAAA,IAAKoL,OAAA,CAAQtM,MAAA,EAAQ;QACxB,OAAO,MAAM,CAAC;MACf;MACA,MAAMwM,MAAA,GAASF,OAAA,CAAQpL,CAAC;MAExB,OAAO,YAAY;QAClB,MAAMuL,IAAA,GAAOF,UAAA,CAAWrL,CAAA,GAAI,CAAC;QAC7B,IAAIwL,UAAA,GAAa;QACjB,IAAIC,YAAA,GAAe;QAEnB,MAAMH,MAAA,CAAO9J,YAAA,OAAK3E,KAAA,GAAO6M,OAAA,EAAS,YAAY;UAC7C,IAAI8B,UAAA,EAAY;YACf,MAAM,IAAI/L,KAAA,CAAM,uDAAuDO,CAAC,EAAE;UAC3E;UAEAwL,UAAA,GAAa;UAEb,MAAMD,IAAA,CAAK;UAEXE,YAAA,GAAe;QAChB,CAAC;QAED,IAAI,CAACD,UAAA,EAAY;UAChB,MAAM,IAAI/L,KAAA,CAAM,8CAA8CO,CAAC,EAAE;QAClE;QAEA,IAAI,CAACyL,YAAA,EAAc;UAClB,MAAM,IAAIhM,KAAA,CAAM,+CAA+CO,CAAC,EAAE;QACnE;MACD;IACD;IAEA,MAAMqL,UAAA,CAAW,CAAC,EAAE;EACrB,UAAE;IACD/I,YAAA,OAAK9F,aAAA,EAAgBgF,YAAA,OAAK3E,KAAA,EAAM4E,MAAA,CAAOmB,KAAA,CAAM;IAC7CN,YAAA,OAAK7F,eAAA,EAAkB+E,YAAA,OAAK3E,KAAA,EAAMgG,QAAA,CAASD,KAAA,CAAM;EAClD;AACD;AAEMtF,sBAAA,GAAoB,eAAAA,CAAA,EAAG;EAC5B,OAAOkE,YAAA,OAAK7E,gBAAA,EAAiB4N,IAAA,GAAO,GAAG;IACtC,MAAMmB,UAAA,GAAaxE,OAAA,CAAQyE,GAAA,CAAInK,YAAA,OAAK7E,gBAAA,CAAgB;IACpD6E,YAAA,OAAK7E,gBAAA,EAAiBiP,KAAA,CAAM;IAC5BpK,YAAA,OAAK7E,gBAAA,EAAiB0E,GAAA,CAAIqK,UAAU;IACpC,MAAMA,UAAA;IACNlK,YAAA,OAAK7E,gBAAA,EAAiBkH,MAAA,CAAO6H,UAAU;EACxC;AACD;AAEAnO,wBAAA,GAAsB,SAAAA,CAAA,EAAG;EACxB,MAAMsO,iBAAA,GAAoBrK,YAAA,OAAK3E,KAAA,EAAMgG,QAAA;EACrC,MAAMiJ,eAAA,GAAkBtK,YAAA,OAAK3E,KAAA,EAAM4E,MAAA;EAEnC,MAAMsK,eAAA,GAAmBvK,YAAA,OAAK/E,eAAA,EAA8BuP,IAAA,CAAKjN,QAAQ;EACzE,MAAMkN,aAAA,GAAiBzK,YAAA,OAAKhF,aAAA,EAA4BwP,IAAA,CAAKjN,QAAQ;EAErE,IAAIgN,eAAA,CAAgBjN,MAAA,KAAW+M,iBAAA,CAAkB/M,MAAA,EAAQ;IACxD,MAAM,IAAIW,KAAA,CAAM,yDAAyD;EAC1E;EAEA,IAAIwM,aAAA,CAAcnN,MAAA,KAAWgN,eAAA,CAAgBhN,MAAA,EAAQ;IACpD,MAAM,IAAIW,KAAA,CAAM,uDAAuD;EACxE;EAEA,MAAMyM,gBAAA,GAAmBH,eAAA,CAAgBI,MAAA,CACvC1B,GAAA,IAAQA,GAAA,CAAIzD,OAAA,EAASpD,IAAA,KAAS,uBAChC;EAEApC,YAAA,OAAK3E,KAAA,EAAMgG,QAAA,GAAWqJ,gBAAA;EACtB1K,YAAA,OAAK3E,KAAA,EAAM4E,MAAA,GAASwK,aAAA;EACpB3J,YAAA,OAAK7F,eAAA,EAAkByP,gBAAA;EACvB5J,YAAA,OAAK9F,aAAA,EAAgByP,aAAA;EACrB3J,YAAA,OAAK5F,iBAAA,EAAoB,IAAIwE,GAAA,CAAIgL,gBAAA,CAAiBpJ,GAAA,CAAI,CAACC,CAAA,EAAG/C,CAAA,KAAMA,CAAC,CAAC;EAElE,SAASoM,iBAAiBvN,KAAA,EAAuB;IAChD,MAAM+H,OAAA,GAAUiF,iBAAA,CAAkBhN,KAAK;IACvC,IAAI+H,OAAA,CAAQI,OAAA,EAASpD,IAAA,KAAS,yBAAyB;MACtD,MAAMkD,MAAA,GAASF,OAAA,CAAQI,OAAA,CAAQC,IAAA,CAAKH,MAAA;MAEpC,IAAIA,MAAA,IAAU,MAAM;QACnB,MAAM,IAAIrH,KAAA,CAAM,6CAA6C;MAC9D;MAEA,OAAO2M,gBAAA,CAAiBtF,MAAA,CAAO5H,MAAM;IACtC;IAEA,MAAMmN,OAAA,GAAUH,gBAAA,CAAiBnK,OAAA,CAAQ6E,OAAO;IAEhD,IAAIyF,OAAA,KAAY,IAAI;MACnB,MAAM,IAAI5M,KAAA,CAAM,2CAA2C;IAC5D;IAEA,OAAO4M,OAAA;EACR;EAEA7K,YAAA,OAAK3E,KAAA,EAAMyP,YAAA,CAAcvD,GAAA,IAAQ;IAChC,IAAIA,GAAA,CAAI9J,KAAA,KAAU,SAAS;MAC1B,MAAMoN,OAAA,GAAUJ,aAAA,CAAclK,OAAA,CAAQ+J,eAAA,CAAgB/C,GAAA,CAAIjH,KAAK,CAAC;MAEhE,IAAIuK,OAAA,KAAY,IAAI;QACnB,MAAM,IAAI5M,KAAA,CAAM,6BAA6B;MAC9C;MAEA,OAAO;QAAE,GAAGsJ,GAAA;QAAKjH,KAAA,EAAOuK;MAAQ;IACjC,WAAWtD,GAAA,CAAI9J,KAAA,KAAU,UAAU;MAClC,MAAMoN,OAAA,GAAUD,gBAAA,CAAiBrD,GAAA,CAAI7J,MAAM;MAE3C,OAAO;QAAE,GAAG6J,GAAA;QAAK7J,MAAA,EAAQmN;MAAQ;IAClC,WAAWtD,GAAA,CAAI9J,KAAA,KAAU,gBAAgB;MACxC,MAAMoN,OAAA,GAAUD,gBAAA,CAAiBrD,GAAA,CAAIzJ,YAAA,CAAa,CAAC,CAAC;MAEpD,OAAO;QAAE,GAAGyJ,GAAA;QAAKzJ,YAAA,EAAc,CAAC+M,OAAA,EAAStD,GAAA,CAAIzJ,YAAA,CAAa,CAAC,CAAC;MAAE;IAC/D;IAEA,OAAOyJ,GAAA;EACR,CAAC;EAED,WAAW,CAAC/I,CAAA,EAAGyK,GAAG,KAAKoB,iBAAA,CAAkBU,OAAA,CAAQ,GAAG;IACnD,IAAI9B,GAAA,CAAIzD,OAAA,EAASpD,IAAA,KAAS,yBAAyB;MAClD,IAAI;QACH6G,GAAA,CAAIzD,OAAA,CAAQC,IAAA,CAAK5H,WAAA,GAAc+M,gBAAA,CAAiBpM,CAAC;MAClD,QAAQ,CAER;IACD;EACD;AACD;AAxtBM,IAAMwM,WAAA,GAANzL,YAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}