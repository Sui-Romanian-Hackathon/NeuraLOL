{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _write, _serialize, _schema, _bytes;\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from \"@mysten/utils\";\nimport { BcsReader } from \"./reader.js\";\nimport { ulebEncode } from \"./uleb.js\";\nimport { BcsWriter } from \"./writer.js\";\nconst _BcsType = class _BcsType {\n  constructor(options) {\n    __privateAdd(this, _write);\n    __privateAdd(this, _serialize);\n    this.name = options.name;\n    this.read = options.read;\n    this.serializedSize = options.serializedSize ?? (() => null);\n    __privateSet(this, _write, options.write);\n    __privateSet(this, _serialize, options.serialize ?? ((value, options2) => {\n      const writer = new BcsWriter({\n        initialSize: this.serializedSize(value) ?? void 0,\n        ...options2\n      });\n      __privateGet(this, _write).call(this, value, writer);\n      return writer.toBytes();\n    }));\n    this.validate = options.validate ?? (() => {});\n  }\n  write(value, writer) {\n    this.validate(value);\n    __privateGet(this, _write).call(this, value, writer);\n  }\n  serialize(value, options) {\n    this.validate(value);\n    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n  }\n  parse(bytes) {\n    const reader = new BcsReader(bytes);\n    return this.read(reader);\n  }\n  fromHex(hex) {\n    return this.parse(fromHex(hex));\n  }\n  fromBase58(b64) {\n    return this.parse(fromBase58(b64));\n  }\n  fromBase64(b64) {\n    return this.parse(fromBase64(b64));\n  }\n  transform({\n    name,\n    input,\n    output,\n    validate\n  }) {\n    return new _BcsType({\n      name: name ?? this.name,\n      read: reader => output ? output(this.read(reader)) : this.read(reader),\n      write: (value, writer) => __privateGet(this, _write).call(this, input ? input(value) : value, writer),\n      serializedSize: value => this.serializedSize(input ? input(value) : value),\n      serialize: (value, options) => __privateGet(this, _serialize).call(this, input ? input(value) : value, options),\n      validate: value => {\n        validate?.(value);\n        this.validate(input ? input(value) : value);\n      }\n    });\n  }\n};\n_write = new WeakMap();\n_serialize = new WeakMap();\nlet BcsType = _BcsType;\nconst SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n  return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nclass SerializedBcs {\n  constructor(schema, bytes) {\n    __privateAdd(this, _schema);\n    __privateAdd(this, _bytes);\n    __privateSet(this, _schema, schema);\n    __privateSet(this, _bytes, bytes);\n  }\n  // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n  // of the @mysten/bcs package are installed\n  get [SERIALIZED_BCS_BRAND]() {\n    return true;\n  }\n  toBytes() {\n    return __privateGet(this, _bytes);\n  }\n  toHex() {\n    return toHex(__privateGet(this, _bytes));\n  }\n  toBase64() {\n    return toBase64(__privateGet(this, _bytes));\n  }\n  toBase58() {\n    return toBase58(__privateGet(this, _bytes));\n  }\n  parse() {\n    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n  }\n}\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType({\n  size,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    serializedSize: () => size\n  });\n}\nfunction uIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](value),\n    validate: value => {\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction bigUIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](BigInt(value)),\n    validate: val => {\n      const value = BigInt(val);\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction dynamicSizeBcsType({\n  serialize,\n  ...options\n}) {\n  const type = new BcsType({\n    ...options,\n    serialize,\n    write: (value, writer) => {\n      for (const byte of type.serialize(value).toBytes()) {\n        writer.write8(byte);\n      }\n    }\n  });\n  return type;\n}\nfunction stringLikeBcsType({\n  toBytes,\n  fromBytes,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    read: reader => {\n      const length = reader.readULEB();\n      const bytes = reader.readBytes(length);\n      return fromBytes(bytes);\n    },\n    write: (hex, writer) => {\n      const bytes = toBytes(hex);\n      writer.writeULEB(bytes.length);\n      for (let i = 0; i < bytes.length; i++) {\n        writer.write8(bytes[i]);\n      }\n    },\n    serialize: value => {\n      const bytes = toBytes(value);\n      const size = ulebEncode(bytes.length);\n      const result = new Uint8Array(size.length + bytes.length);\n      result.set(size, 0);\n      result.set(bytes, size.length);\n      return result;\n    },\n    validate: value => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction lazyBcsType(cb) {\n  let lazyType = null;\n  function getType() {\n    if (!lazyType) {\n      lazyType = cb();\n    }\n    return lazyType;\n  }\n  return new BcsType({\n    name: \"lazy\",\n    read: data => getType().read(data),\n    serializedSize: value => getType().serializedSize(value),\n    write: (value, writer) => getType().write(value, writer),\n    serialize: (value, options) => getType().serialize(value, options).toBytes()\n  });\n}\nclass BcsStruct extends BcsType {\n  constructor({\n    name,\n    fields,\n    ...options\n  }) {\n    const canonicalOrder = Object.entries(fields);\n    super({\n      name,\n      serializedSize: values => {\n        let total = 0;\n        for (const [field, type] of canonicalOrder) {\n          const size = type.serializedSize(values[field]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = {};\n        for (const [field, type] of canonicalOrder) {\n          result[field] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const [field, type] of canonicalOrder) {\n          type.write(value[field], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n      }\n    });\n  }\n}\nclass BcsEnum extends BcsType {\n  constructor({\n    fields,\n    ...options\n  }) {\n    const canonicalOrder = Object.entries(fields);\n    super({\n      read: reader => {\n        const index = reader.readULEB();\n        const enumEntry = canonicalOrder[index];\n        if (!enumEntry) {\n          throw new TypeError(`Unknown value ${index} for enum ${options.name}`);\n        }\n        const [kind, type] = enumEntry;\n        return {\n          [kind]: type?.read(reader) ?? true,\n          $kind: kind\n        };\n      },\n      write: (value, writer) => {\n        const [name, val] = Object.entries(value).filter(([name2]) => Object.hasOwn(fields, name2))[0];\n        for (let i = 0; i < canonicalOrder.length; i++) {\n          const [optionName, optionType] = canonicalOrder[i];\n          if (optionName === name) {\n            writer.writeULEB(i);\n            optionType?.write(val, writer);\n            return;\n          }\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n        const keys = Object.keys(value).filter(k => value[k] !== void 0 && Object.hasOwn(fields, k));\n        if (keys.length !== 1) {\n          throw new TypeError(`Expected object with one key, but found ${keys.length} for type ${options.name}}`);\n        }\n        const [variant] = keys;\n        if (!Object.hasOwn(fields, variant)) {\n          throw new TypeError(`Invalid enum variant ${variant}`);\n        }\n      }\n    });\n  }\n}\nclass BcsTuple extends BcsType {\n  constructor({\n    fields,\n    name,\n    ...options\n  }) {\n    super({\n      name: name ?? `(${fields.map(t => t.name).join(\", \")})`,\n      serializedSize: values => {\n        let total = 0;\n        for (let i = 0; i < fields.length; i++) {\n          const size = fields[i].serializedSize(values[i]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = [];\n        for (const field of fields) {\n          result.push(field.read(reader));\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (let i = 0; i < fields.length; i++) {\n          fields[i].write(value[i], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!Array.isArray(value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== fields.length) {\n          throw new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);\n        }\n      }\n    });\n  }\n}\nexport { BcsEnum, BcsStruct, BcsTuple, BcsType, SerializedBcs, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, isSerializedBcs, lazyBcsType, stringLikeBcsType, uIntBcsType };","map":{"version":3,"names":["_write","_serialize","_schema","_bytes","fromBase58","fromBase64","toBase58","toBase64","fromHex","toHex","BcsReader","ulebEncode","BcsWriter","_BcsType","constructor","options","__privateAdd","name","read","serializedSize","__privateSet","write","serialize","value","options2","writer","initialSize","__privateGet","call","toBytes","validate","SerializedBcs","parse","bytes","reader","hex","b64","transform","input","output","WeakMap","BcsType","SERIALIZED_BCS_BRAND","Symbol","for","isSerializedBcs","obj","schema","fixedSizeBcsType","size","uIntBcsType","readMethod","writeMethod","maxValue","TypeError","bigUIntBcsType","BigInt","val","dynamicSizeBcsType","type","byte","write8","stringLikeBcsType","fromBytes","length","readULEB","readBytes","writeULEB","i","result","Uint8Array","set","lazyBcsType","cb","lazyType","getType","data","BcsStruct","fields","canonicalOrder","Object","entries","values","total","field","BcsEnum","index","enumEntry","kind","$kind","filter","name2","hasOwn","optionName","optionType","keys","k","variant","BcsTuple","map","t","join","push","Array","isArray"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/bcs/src/bcs-type.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from '@mysten/utils';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\nimport type { EnumInputShape, EnumOutputShape, JoinString } from './types.js';\n\nexport interface BcsTypeOptions<T, Input = T, Name extends string = string> {\n\tname?: Name;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T, const Name extends string = string> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: Name;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input, Name>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input, NewName extends string = Name>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2, NewName>) {\n\t\treturn new BcsType<T2, Input2, NewName>({\n\t\t\tname: (name ?? this.name) as NewName,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array<ArrayBuffer>;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(schema: BcsType<T, Input>, bytes: Uint8Array<ArrayBuffer>) {\n\t\tthis.#schema = schema;\n\t\tthis.#bytes = bytes;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T, const Name extends string = string>({\n\tsize,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input, Name>) {\n\treturn new BcsType<T, Input, Name>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number, Name>) {\n\treturn fixedSizeBcsType<number, number, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T, const Name extends string = string>({\n\tserialize,\n\t...options\n}: {\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType<const Name extends string = string>({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: Name;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string, string, Name>) {\n\treturn new BcsType<string, string, Name>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n\nexport interface BcsStructOptions<\n\tT extends Record<string, BcsType<any>>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsType<\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t},\n\tName\n> {\n\tconstructor({ name, fields, ...options }: BcsStructOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\tsuper({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsEnumOptions<\n\tT extends Record<string, BcsType<any> | null>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t}>,\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string = string,\n> extends BcsType<\n\tEnumOutputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t}>,\n\tEnumInputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t}>,\n\tName\n> {\n\tconstructor({ fields, ...options }: BcsEnumOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields as object);\n\t\tsuper({\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${options.name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(fields, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(fields, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${options.name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(fields, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsTupleOptions<T extends readonly BcsType<any>[], Name extends string>\n\textends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname?: Name;\n\tfields: T;\n}\n\nexport class BcsTuple<\n\tconst T extends readonly BcsType<any>[],\n\tconst Name extends\n\t\tstring = `(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n> extends BcsType<\n\t{\n\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t},\n\tName\n> {\n\tconstructor({ fields, name, ...options }: BcsTupleOptions<T, Name>) {\n\t\tsuper({\n\t\t\tname: name ?? (`(${fields.map((t) => t.name).join(', ')})` as never),\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tconst size = fields[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const field of fields) {\n\t\t\t\t\tresult.push(field.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tfields[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== fields.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}