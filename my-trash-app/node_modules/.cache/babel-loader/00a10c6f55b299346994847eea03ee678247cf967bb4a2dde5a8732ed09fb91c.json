{"ast":null,"code":"import { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from \"@mysten/bcs\";\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { TypeTagSerializer } from \"./type-tag-serializer.js\";\nfunction unsafe_u64(options) {\n  return bcs.u64({\n    name: \"unsafe_u64\",\n    ...options\n  }).transform({\n    input: val => val,\n    output: val => Number(val)\n  });\n}\nfunction optionEnum(type) {\n  return bcs.enum(\"Option\", {\n    None: null,\n    Some: type\n  });\n}\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n  validate: val => {\n    const address = typeof val === \"string\" ? val : toHex(val);\n    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n      throw new Error(`Invalid Sui address ${address}`);\n    }\n  },\n  input: val => typeof val === \"string\" ? fromHex(normalizeSuiAddress(val)) : val,\n  output: val => normalizeSuiAddress(toHex(val))\n});\nconst ObjectDigest = bcs.byteVector().transform({\n  name: \"ObjectDigest\",\n  input: value => fromBase58(value),\n  output: value => toBase58(new Uint8Array(value)),\n  validate: value => {\n    if (fromBase58(value).length !== 32) {\n      throw new Error(\"ObjectDigest must be 32 bytes\");\n    }\n  }\n});\nconst SuiObjectRef = bcs.struct(\"SuiObjectRef\", {\n  objectId: Address,\n  version: bcs.u64(),\n  digest: ObjectDigest\n});\nconst SharedObjectRef = bcs.struct(\"SharedObjectRef\", {\n  objectId: Address,\n  initialSharedVersion: bcs.u64(),\n  mutable: bcs.bool()\n});\nconst ObjectArg = bcs.enum(\"ObjectArg\", {\n  ImmOrOwnedObject: SuiObjectRef,\n  SharedObject: SharedObjectRef,\n  Receiving: SuiObjectRef\n});\nconst Owner = bcs.enum(\"Owner\", {\n  AddressOwner: Address,\n  ObjectOwner: Address,\n  Shared: bcs.struct(\"Shared\", {\n    initialSharedVersion: bcs.u64()\n  }),\n  Immutable: null,\n  ConsensusAddressOwner: bcs.struct(\"ConsensusAddressOwner\", {\n    owner: Address,\n    startVersion: bcs.u64()\n  })\n});\nconst CallArg = bcs.enum(\"CallArg\", {\n  Pure: bcs.struct(\"Pure\", {\n    bytes: bcs.byteVector().transform({\n      input: val => typeof val === \"string\" ? fromBase64(val) : val,\n      output: val => toBase64(new Uint8Array(val))\n    })\n  }),\n  Object: ObjectArg\n});\nconst InnerTypeTag = bcs.enum(\"TypeTag\", {\n  bool: null,\n  u8: null,\n  u64: null,\n  u128: null,\n  address: null,\n  signer: null,\n  vector: bcs.lazy(() => InnerTypeTag),\n  struct: bcs.lazy(() => StructTag),\n  u16: null,\n  u32: null,\n  u256: null\n});\nconst TypeTag = InnerTypeTag.transform({\n  input: typeTag => typeof typeTag === \"string\" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n  output: typeTag => TypeTagSerializer.tagToString(typeTag)\n});\nconst Argument = bcs.enum(\"Argument\", {\n  GasCoin: null,\n  Input: bcs.u16(),\n  Result: bcs.u16(),\n  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])\n});\nconst ProgrammableMoveCall = bcs.struct(\"ProgrammableMoveCall\", {\n  package: Address,\n  module: bcs.string(),\n  function: bcs.string(),\n  typeArguments: bcs.vector(TypeTag),\n  arguments: bcs.vector(Argument)\n});\nconst Command = bcs.enum(\"Command\", {\n  /**\n   * A Move Call - any public Move function can be called via\n   * this transaction. The results can be used that instant to pass\n   * into the next transaction.\n   */\n  MoveCall: ProgrammableMoveCall,\n  /**\n   * Transfer vector of objects to a receiver.\n   */\n  TransferObjects: bcs.struct(\"TransferObjects\", {\n    objects: bcs.vector(Argument),\n    address: Argument\n  }),\n  // /**\n  //  * Split `amount` from a `coin`.\n  //  */\n  SplitCoins: bcs.struct(\"SplitCoins\", {\n    coin: Argument,\n    amounts: bcs.vector(Argument)\n  }),\n  // /**\n  //  * Merge Vector of Coins (`sources`) into a `destination`.\n  //  */\n  MergeCoins: bcs.struct(\"MergeCoins\", {\n    destination: Argument,\n    sources: bcs.vector(Argument)\n  }),\n  // /**\n  //  * Publish a Move module.\n  //  */\n  Publish: bcs.struct(\"Publish\", {\n    modules: bcs.vector(bcs.byteVector().transform({\n      input: val => typeof val === \"string\" ? fromBase64(val) : val,\n      output: val => toBase64(new Uint8Array(val))\n    })),\n    dependencies: bcs.vector(Address)\n  }),\n  // /**\n  //  * Build a vector of objects using the input arguments.\n  //  * It is impossible to export construct a `vector<T: key>` otherwise,\n  //  * so this call serves a utility function.\n  //  */\n  MakeMoveVec: bcs.struct(\"MakeMoveVec\", {\n    type: optionEnum(TypeTag).transform({\n      input: val => val === null ? {\n        None: true\n      } : {\n        Some: val\n      },\n      output: val => val.Some ?? null\n    }),\n    elements: bcs.vector(Argument)\n  }),\n  Upgrade: bcs.struct(\"Upgrade\", {\n    modules: bcs.vector(bcs.byteVector().transform({\n      input: val => typeof val === \"string\" ? fromBase64(val) : val,\n      output: val => toBase64(new Uint8Array(val))\n    })),\n    dependencies: bcs.vector(Address),\n    package: Address,\n    ticket: Argument\n  })\n});\nconst ProgrammableTransaction = bcs.struct(\"ProgrammableTransaction\", {\n  inputs: bcs.vector(CallArg),\n  commands: bcs.vector(Command)\n});\nconst TransactionKind = bcs.enum(\"TransactionKind\", {\n  ProgrammableTransaction,\n  ChangeEpoch: null,\n  Genesis: null,\n  ConsensusCommitPrologue: null\n});\nconst TransactionExpiration = bcs.enum(\"TransactionExpiration\", {\n  None: null,\n  Epoch: unsafe_u64()\n});\nconst StructTag = bcs.struct(\"StructTag\", {\n  address: Address,\n  module: bcs.string(),\n  name: bcs.string(),\n  typeParams: bcs.vector(InnerTypeTag)\n});\nconst GasData = bcs.struct(\"GasData\", {\n  payment: bcs.vector(SuiObjectRef),\n  owner: Address,\n  price: bcs.u64(),\n  budget: bcs.u64()\n});\nconst TransactionDataV1 = bcs.struct(\"TransactionDataV1\", {\n  kind: TransactionKind,\n  sender: Address,\n  gasData: GasData,\n  expiration: TransactionExpiration\n});\nconst TransactionData = bcs.enum(\"TransactionData\", {\n  V1: TransactionDataV1\n});\nconst IntentScope = bcs.enum(\"IntentScope\", {\n  TransactionData: null,\n  TransactionEffects: null,\n  CheckpointSummary: null,\n  PersonalMessage: null\n});\nconst IntentVersion = bcs.enum(\"IntentVersion\", {\n  V0: null\n});\nconst AppId = bcs.enum(\"AppId\", {\n  Sui: null\n});\nconst Intent = bcs.struct(\"Intent\", {\n  scope: IntentScope,\n  version: IntentVersion,\n  appId: AppId\n});\nfunction IntentMessage(T) {\n  return bcs.struct(`IntentMessage<${T.name}>`, {\n    intent: Intent,\n    value: T\n  });\n}\nconst CompressedSignature = bcs.enum(\"CompressedSignature\", {\n  ED25519: bcs.bytes(64),\n  Secp256k1: bcs.bytes(64),\n  Secp256r1: bcs.bytes(64),\n  ZkLogin: bcs.byteVector(),\n  Passkey: bcs.byteVector()\n});\nconst PublicKey = bcs.enum(\"PublicKey\", {\n  ED25519: bcs.bytes(32),\n  Secp256k1: bcs.bytes(33),\n  Secp256r1: bcs.bytes(33),\n  ZkLogin: bcs.byteVector(),\n  Passkey: bcs.bytes(33)\n});\nconst MultiSigPkMap = bcs.struct(\"MultiSigPkMap\", {\n  pubKey: PublicKey,\n  weight: bcs.u8()\n});\nconst MultiSigPublicKey = bcs.struct(\"MultiSigPublicKey\", {\n  pk_map: bcs.vector(MultiSigPkMap),\n  threshold: bcs.u16()\n});\nconst MultiSig = bcs.struct(\"MultiSig\", {\n  sigs: bcs.vector(CompressedSignature),\n  bitmap: bcs.u16(),\n  multisig_pk: MultiSigPublicKey\n});\nconst base64String = bcs.byteVector().transform({\n  input: val => typeof val === \"string\" ? fromBase64(val) : val,\n  output: val => toBase64(new Uint8Array(val))\n});\nconst SenderSignedTransaction = bcs.struct(\"SenderSignedTransaction\", {\n  intentMessage: IntentMessage(TransactionData),\n  txSignatures: bcs.vector(base64String)\n});\nconst SenderSignedData = bcs.vector(SenderSignedTransaction, {\n  name: \"SenderSignedData\"\n});\nconst PasskeyAuthenticator = bcs.struct(\"PasskeyAuthenticator\", {\n  authenticatorData: bcs.byteVector(),\n  clientDataJson: bcs.string(),\n  userSignature: bcs.byteVector()\n});\nexport { Address, AppId, Argument, CallArg, Command, CompressedSignature, GasData, Intent, IntentMessage, IntentScope, IntentVersion, MultiSig, MultiSigPkMap, MultiSigPublicKey, ObjectArg, ObjectDigest, Owner, PasskeyAuthenticator, ProgrammableMoveCall, ProgrammableTransaction, PublicKey, SenderSignedData, SenderSignedTransaction, SharedObjectRef, StructTag, SuiObjectRef, TransactionData, TransactionDataV1, TransactionExpiration, TransactionKind, TypeTag, base64String };","map":{"version":3,"names":["bcs","fromBase58","fromBase64","fromHex","toBase58","toBase64","toHex","isValidSuiAddress","normalizeSuiAddress","SUI_ADDRESS_LENGTH","TypeTagSerializer","unsafe_u64","options","u64","name","transform","input","val","output","Number","optionEnum","type","enum","None","Some","Address","bytes","validate","address","Error","ObjectDigest","byteVector","value","Uint8Array","length","SuiObjectRef","struct","objectId","version","digest","SharedObjectRef","initialSharedVersion","mutable","bool","ObjectArg","ImmOrOwnedObject","SharedObject","Receiving","Owner","AddressOwner","ObjectOwner","Shared","Immutable","ConsensusAddressOwner","owner","startVersion","CallArg","Pure","Object","InnerTypeTag","u8","u128","signer","vector","lazy","StructTag","u16","u32","u256","TypeTag","typeTag","parseFromStr","tagToString","Argument","GasCoin","Input","Result","NestedResult","tuple","ProgrammableMoveCall","package","module","string","function","typeArguments","arguments","Command","MoveCall","TransferObjects","objects","SplitCoins","coin","amounts","MergeCoins","destination","sources","Publish","modules","dependencies","MakeMoveVec","elements","Upgrade","ticket","ProgrammableTransaction","inputs","commands","TransactionKind","ChangeEpoch","Genesis","ConsensusCommitPrologue","TransactionExpiration","Epoch","typeParams","GasData","payment","price","budget","TransactionDataV1","kind","sender","gasData","expiration","TransactionData","V1","IntentScope","TransactionEffects","CheckpointSummary","PersonalMessage","IntentVersion","V0","AppId","Sui","Intent","scope","appId","IntentMessage","T","intent","CompressedSignature","ED25519","Secp256k1","Secp256r1","ZkLogin","Passkey","PublicKey","MultiSigPkMap","pubKey","weight","MultiSigPublicKey","pk_map","threshold","MultiSig","sigs","bitmap","multisig_pk","base64String","SenderSignedTransaction","intentMessage","txSignatures","SenderSignedData","PasskeyAuthenticator","authenticatorData","clientDataJson","userSignature"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/sui/src/bcs/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHex(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHex(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.byteVector().transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromBase58(value),\n\toutput: (value) => toBase58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromBase58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n\tAddressOwner: Address,\n\tObjectOwner: Address,\n\tShared: bcs.struct('Shared', {\n\t\tinitialSharedVersion: bcs.u64(),\n\t}),\n\tImmutable: null,\n\tConsensusAddressOwner: bcs.struct('ConsensusAddressOwner', {\n\t\towner: Address,\n\t\tstartVersion: bcs.u64(),\n\t}),\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.byteVector().transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.byteVector().transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t\t},\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.byteVector().transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.bytes(64),\n\tSecp256k1: bcs.bytes(64),\n\tSecp256r1: bcs.bytes(64),\n\tZkLogin: bcs.byteVector(),\n\tPasskey: bcs.byteVector(),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.bytes(32),\n\tSecp256k1: bcs.bytes(33),\n\tSecp256r1: bcs.bytes(33),\n\tZkLogin: bcs.byteVector(),\n\tPasskey: bcs.bytes(33),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.byteVector().transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\toutput: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n\tauthenticatorData: bcs.byteVector(),\n\tclientDataJson: bcs.string(),\n\tuserSignature: bcs.byteVector(),\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}