{"ast":null,"code":"class DataLoader {\n  constructor(batchLoadFn, options) {\n    if (typeof batchLoadFn !== \"function\") {\n      throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${batchLoadFn}.`);\n    }\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n    this.name = getValidName(options);\n  }\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  load(key) {\n    if (key === null || key === void 0) {\n      throw new TypeError(`The loader.load() function must be called with a value, but got: ${String(key)}.`);\n    }\n    const batch = getCurrentBatch(this);\n    const cacheMap = this._cacheMap;\n    let cacheKey;\n    if (cacheMap) {\n      cacheKey = this._cacheKeyFn(key);\n      const cachedPromise = cacheMap.get(cacheKey);\n      if (cachedPromise) {\n        const cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(resolve => {\n          cacheHits.push(() => {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    }\n    batch.keys.push(key);\n    const promise = new Promise((resolve, reject) => {\n      batch.callbacks.push({\n        resolve,\n        reject\n      });\n    });\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError(`The loader.loadMany() function must be called with Array<key>, but got: ${keys}.`);\n    }\n    const loadPromises = [];\n    for (let i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i]).catch(error => error));\n    }\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  clear(key) {\n    const cacheMap = this._cacheMap;\n    if (cacheMap) {\n      const cacheKey = this._cacheKeyFn(key);\n      cacheMap.delete(cacheKey);\n    }\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  clearAll() {\n    const cacheMap = this._cacheMap;\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  prime(key, value) {\n    const cacheMap = this._cacheMap;\n    if (cacheMap) {\n      const cacheKey = this._cacheKeyFn(key);\n      if (cacheMap.get(cacheKey) === void 0) {\n        let promise;\n        if (value instanceof Error) {\n          promise = Promise.reject(value);\n          promise.catch(() => {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n    return this;\n  }\n}\nconst enqueuePostPromiseJob = /** @ts-ignore */\ntypeof process === \"object\" && typeof process.nextTick === \"function\" ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n  resolvedPromise.then(() => {\n    process.nextTick(fn);\n  });\n} :\n// @ts-ignore\ntypeof setImmediate === \"function\" ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n};\nlet resolvedPromise;\nfunction getCurrentBatch(loader) {\n  const existingBatch = loader._batch;\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {\n    return existingBatch;\n  }\n  const newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  };\n  loader._batch = newBatch;\n  loader._batchScheduleFn(() => {\n    dispatchBatch(loader, newBatch);\n  });\n  return newBatch;\n}\nfunction dispatchBatch(loader, batch) {\n  batch.hasDispatched = true;\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  }\n  let batchPromise;\n  try {\n    batchPromise = loader._batchLoadFn(batch.keys);\n  } catch (e) {\n    return failedDispatch(loader, batch, new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(e)}.`));\n  }\n  if (!batchPromise || typeof batchPromise.then !== \"function\") {\n    return failedDispatch(loader, batch, new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(batchPromise)}.`));\n  }\n  Promise.resolve(batchPromise).then(values => {\n    if (!isArrayLike(values)) {\n      throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(values)}.`);\n    }\n    if (values.length !== batch.keys.length) {\n      throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.\n\nKeys:\n${String(batch.keys)}\n\nValues:\n${String(values)}`);\n    }\n    resolveCacheHits(batch);\n    for (let i = 0; i < batch.callbacks.length; i++) {\n      const value = values[i];\n      if (value instanceof Error) {\n        batch.callbacks[i].reject(value);\n      } else {\n        batch.callbacks[i].resolve(value);\n      }\n    }\n  }).catch(error => {\n    failedDispatch(loader, batch, error);\n  });\n}\nfunction failedDispatch(loader, batch, error) {\n  resolveCacheHits(batch);\n  for (let i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n}\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (let i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n}\nfunction getValidMaxBatchSize(options) {\n  const shouldBatch = !options || options.batch !== false;\n  if (!shouldBatch) {\n    return 1;\n  }\n  const maxBatchSize = options && options.maxBatchSize;\n  if (maxBatchSize === void 0) {\n    return Infinity;\n  }\n  if (typeof maxBatchSize !== \"number\" || maxBatchSize < 1) {\n    throw new TypeError(`maxBatchSize must be a positive number: ${maxBatchSize}`);\n  }\n  return maxBatchSize;\n}\nfunction getValidBatchScheduleFn(options) {\n  const batchScheduleFn = options && options.batchScheduleFn;\n  if (batchScheduleFn === void 0) {\n    return enqueuePostPromiseJob;\n  }\n  if (typeof batchScheduleFn !== \"function\") {\n    throw new TypeError(`batchScheduleFn must be a function: ${batchScheduleFn}`);\n  }\n  return batchScheduleFn;\n}\nfunction getValidCacheKeyFn(options) {\n  const cacheKeyFn = options && options.cacheKeyFn;\n  if (cacheKeyFn === void 0) {\n    return key => key;\n  }\n  if (typeof cacheKeyFn !== \"function\") {\n    throw new TypeError(`cacheKeyFn must be a function: ${cacheKeyFn}`);\n  }\n  return cacheKeyFn;\n}\nfunction getValidCacheMap(options) {\n  const shouldCache = !options || options.cache !== false;\n  if (!shouldCache) {\n    return null;\n  }\n  const cacheMap = options && options.cacheMap;\n  if (cacheMap === void 0) {\n    return /* @__PURE__ */new Map();\n  }\n  if (cacheMap !== null) {\n    const cacheFunctions = [\"get\", \"set\", \"delete\", \"clear\"];\n    const missingFunctions = cacheFunctions.filter(fnName => cacheMap && typeof cacheMap[fnName] !== \"function\");\n    if (missingFunctions.length !== 0) {\n      throw new TypeError(\"Custom cacheMap missing methods: \" + missingFunctions.join(\", \"));\n    }\n  }\n  return cacheMap;\n}\nfunction getValidName(options) {\n  if (options && options.name) {\n    return options.name;\n  }\n  return null;\n}\nfunction isArrayLike(x) {\n  return typeof x === \"object\" && x !== null && \"length\" in x && typeof x.length === \"number\" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\nexport { DataLoader };","map":{"version":3,"names":["DataLoader","constructor","batchLoadFn","options","TypeError","_batchLoadFn","_maxBatchSize","getValidMaxBatchSize","_batchScheduleFn","getValidBatchScheduleFn","_cacheKeyFn","getValidCacheKeyFn","_cacheMap","getValidCacheMap","_batch","name","getValidName","load","key","String","batch","getCurrentBatch","cacheMap","cacheKey","cachedPromise","get","cacheHits","Promise","resolve","push","keys","promise","reject","callbacks","set","loadMany","isArrayLike","loadPromises","i","length","catch","error","all","clear","delete","clearAll","prime","value","Error","enqueuePostPromiseJob","process","nextTick","fn","resolvedPromise","then","setImmediate","setTimeout","loader","existingBatch","hasDispatched","newBatch","dispatchBatch","resolveCacheHits","batchPromise","e","failedDispatch","values","shouldBatch","maxBatchSize","Infinity","batchScheduleFn","cacheKeyFn","shouldCache","cache","Map","cacheFunctions","missingFunctions","filter","fnName","join","x","Object","prototype","hasOwnProperty","call"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/utils/src/dataloader.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Copied from https://github.com/graphql/dataloader/blob/a10773043d41a56bde4219c155fcf5633e6c9bcb/src/index.js */\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nexport class DataLoader<K, V, C = K> {\n\tconstructor(batchLoadFn: DataLoader.BatchLoadFn<K, V>, options?: DataLoader.Options<K, V, C>) {\n\t\tif (typeof batchLoadFn !== 'function') {\n\t\t\tthrow new TypeError(\n\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t`Array<key> and returns Promise<Array<value>>, but got: ${batchLoadFn}.`,\n\t\t\t);\n\t\t}\n\t\tthis._batchLoadFn = batchLoadFn;\n\t\tthis._maxBatchSize = getValidMaxBatchSize(options);\n\t\tthis._batchScheduleFn = getValidBatchScheduleFn(options);\n\t\tthis._cacheKeyFn = getValidCacheKeyFn(options);\n\t\tthis._cacheMap = getValidCacheMap(options);\n\t\tthis._batch = null;\n\t\tthis.name = getValidName(options);\n\t}\n\n\t// Private\n\t_batchLoadFn: DataLoader.BatchLoadFn<K, V>;\n\t_maxBatchSize: number;\n\t_batchScheduleFn: (cb: () => void) => void;\n\t_cacheKeyFn: (key: K) => C;\n\t_cacheMap: DataLoader.CacheMap<C, Promise<V>> | null;\n\t_batch: Batch<K, V> | null;\n\n\t/**\n\t * Loads a key, returning a `Promise` for the value represented by that key.\n\t */\n\tload(key: K): Promise<V> {\n\t\tif (key === null || key === undefined) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`The loader.load() function must be called with a value, but got: ${String(key)}.`,\n\t\t\t);\n\t\t}\n\n\t\tconst batch = getCurrentBatch(this);\n\t\tconst cacheMap = this._cacheMap;\n\t\tlet cacheKey: C;\n\n\t\t// If caching and there is a cache-hit, return cached Promise.\n\t\tif (cacheMap) {\n\t\t\tcacheKey = this._cacheKeyFn(key);\n\t\t\tconst cachedPromise = cacheMap.get(cacheKey);\n\t\t\tif (cachedPromise) {\n\t\t\t\tconst cacheHits = batch.cacheHits || (batch.cacheHits = []);\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tcacheHits.push(() => {\n\t\t\t\t\t\tresolve(cachedPromise);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise, produce a new Promise for this key, and enqueue it to be\n\t\t// dispatched along with the current batch.\n\t\tbatch.keys.push(key);\n\t\tconst promise = new Promise<V>((resolve, reject) => {\n\t\t\tbatch.callbacks.push({ resolve, reject });\n\t\t});\n\n\t\t// If caching, cache this promise.\n\t\tif (cacheMap) {\n\t\t\tcacheMap.set(cacheKey!, promise);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Loads multiple keys, promising an array of values:\n\t *\n\t *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n\t *\n\t * This is similar to the more verbose:\n\t *\n\t *     var [ a, b ] = await Promise.all([\n\t *       myLoader.load('a'),\n\t *       myLoader.load('b')\n\t *     ]);\n\t *\n\t * However it is different in the case where any load fails. Where\n\t * Promise.all() would reject, loadMany() always resolves, however each result\n\t * is either a value or an Error instance.\n\t *\n\t *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n\t *     // c instanceof Error\n\t *\n\t */\n\tloadMany(keys: ReadonlyArray<K>): Promise<Array<V | Error>> {\n\t\tif (!isArrayLike(keys)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`The loader.loadMany() function must be called with Array<key>, but got: ${keys}.`,\n\t\t\t);\n\t\t}\n\t\t// Support ArrayLike by using only minimal property access\n\t\tconst loadPromises = [];\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tloadPromises.push(this.load(keys[i]).catch((error) => error));\n\t\t}\n\t\treturn Promise.all(loadPromises);\n\t}\n\n\t/**\n\t * Clears the value at `key` from the cache, if it exists. Returns itself for\n\t * method chaining.\n\t */\n\tclear(key: K): this {\n\t\tconst cacheMap = this._cacheMap;\n\t\tif (cacheMap) {\n\t\t\tconst cacheKey = this._cacheKeyFn(key);\n\t\t\tcacheMap.delete(cacheKey);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clears the entire cache. To be used when some event results in unknown\n\t * invalidations across this particular `DataLoader`. Returns itself for\n\t * method chaining.\n\t */\n\tclearAll(): this {\n\t\tconst cacheMap = this._cacheMap;\n\t\tif (cacheMap) {\n\t\t\tcacheMap.clear();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds the provided key and value to the cache. If the key already\n\t * exists, no change is made. Returns itself for method chaining.\n\t *\n\t * To prime the cache with an error at a key, provide an Error instance.\n\t */\n\tprime(key: K, value: V | Promise<V> | Error): this {\n\t\tconst cacheMap = this._cacheMap;\n\t\tif (cacheMap) {\n\t\t\tconst cacheKey = this._cacheKeyFn(key);\n\n\t\t\t// Only add the key if it does not already exist.\n\t\t\tif (cacheMap.get(cacheKey) === undefined) {\n\t\t\t\t// Cache a rejected promise if the value is an Error, in order to match\n\t\t\t\t// the behavior of load(key).\n\t\t\t\tlet promise;\n\t\t\t\tif (value instanceof Error) {\n\t\t\t\t\tpromise = Promise.reject(value);\n\t\t\t\t\t// Since this is a case where an Error is intentionally being primed\n\t\t\t\t\t// for a given key, we want to disable unhandled promise rejection.\n\t\t\t\t\tpromise.catch(() => {});\n\t\t\t\t} else {\n\t\t\t\t\tpromise = Promise.resolve(value);\n\t\t\t\t}\n\t\t\t\tcacheMap.set(cacheKey, promise);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The name given to this `DataLoader` instance. Useful for APM tools.\n\t *\n\t * Is `null` if not set in the constructor.\n\t */\n\tname: string | null;\n}\n\n// Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\nconst enqueuePostPromiseJob: (fn: () => void) => void =\n\t/** @ts-ignore */\n\ttypeof process === 'object' && typeof process.nextTick === 'function'\n\t\t? function (fn) {\n\t\t\t\tif (!resolvedPromise) {\n\t\t\t\t\tresolvedPromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t\tresolvedPromise.then(() => {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tprocess.nextTick(fn);\n\t\t\t\t});\n\t\t\t}\n\t\t: // @ts-ignore\n\t\t\ttypeof setImmediate === 'function'\n\t\t\t? function (fn) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tsetImmediate(fn);\n\t\t\t\t}\n\t\t\t: function (fn) {\n\t\t\t\t\tsetTimeout(fn);\n\t\t\t\t};\n\n// Private: cached resolved Promise instance\nlet resolvedPromise: Promise<void> | undefined;\n\n// Private: Describes a batch of requests\ntype Batch<K, V> = {\n\thasDispatched: boolean;\n\tkeys: Array<K>;\n\tcallbacks: Array<{\n\t\tresolve: (value: V) => void;\n\t\treject: (error: Error) => void;\n\t}>;\n\tcacheHits?: Array<() => void>;\n};\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch<K, V>(loader: DataLoader<K, V, any>): Batch<K, V> {\n\t// If there is an existing batch which has not yet dispatched and is within\n\t// the limit of the batch size, then return it.\n\tconst existingBatch = loader._batch;\n\tif (\n\t\texistingBatch !== null &&\n\t\t!existingBatch.hasDispatched &&\n\t\texistingBatch.keys.length < loader._maxBatchSize\n\t) {\n\t\treturn existingBatch;\n\t}\n\n\t// Otherwise, create a new batch for this loader.\n\tconst newBatch = { hasDispatched: false, keys: [], callbacks: [] };\n\n\t// Store it on the loader so it may be reused.\n\tloader._batch = newBatch;\n\n\t// Then schedule a task to dispatch this batch of requests.\n\tloader._batchScheduleFn(() => {\n\t\tdispatchBatch(loader, newBatch);\n\t});\n\n\treturn newBatch;\n}\n\nfunction dispatchBatch<K, V>(loader: DataLoader<K, V, any>, batch: Batch<K, V>) {\n\t// Mark this batch as having been dispatched.\n\tbatch.hasDispatched = true;\n\n\t// If there's nothing to load, resolve any cache hits and return early.\n\tif (batch.keys.length === 0) {\n\t\tresolveCacheHits(batch);\n\t\treturn;\n\t}\n\n\t// Call the provided batchLoadFn for this loader with the batch's keys and\n\t// with the loader as the `this` context.\n\tlet batchPromise;\n\ttry {\n\t\tbatchPromise = loader._batchLoadFn(batch.keys);\n\t} catch (e) {\n\t\treturn failedDispatch(\n\t\t\tloader,\n\t\t\tbatch,\n\t\t\tnew TypeError(\n\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function ' +\n\t\t\t\t\t`errored synchronously: ${String(e)}.`,\n\t\t\t),\n\t\t);\n\t}\n\n\t// Assert the expected response from batchLoadFn\n\tif (!batchPromise || typeof batchPromise.then !== 'function') {\n\t\treturn failedDispatch(\n\t\t\tloader,\n\t\t\tbatch,\n\t\t\tnew TypeError(\n\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function did ' +\n\t\t\t\t\t`not return a Promise: ${String(batchPromise)}.`,\n\t\t\t),\n\t\t);\n\t}\n\n\t// Await the resolution of the call to batchLoadFn.\n\tPromise.resolve(batchPromise)\n\t\t.then((values) => {\n\t\t\t// Assert the expected resolution from batchLoadFn.\n\t\t\tif (!isArrayLike(values)) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function did ' +\n\t\t\t\t\t\t`not return a Promise of an Array: ${String(values)}.`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (values.length !== batch.keys.length) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'DataLoader must be constructed with a function which accepts ' +\n\t\t\t\t\t\t'Array<key> and returns Promise<Array<value>>, but the function did ' +\n\t\t\t\t\t\t'not return a Promise of an Array of the same length as the Array ' +\n\t\t\t\t\t\t'of keys.' +\n\t\t\t\t\t\t`\\n\\nKeys:\\n${String(batch.keys)}` +\n\t\t\t\t\t\t`\\n\\nValues:\\n${String(values)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Resolve all cache hits in the same micro-task as freshly loaded values.\n\t\t\tresolveCacheHits(batch);\n\n\t\t\t// Step through values, resolving or rejecting each Promise in the batch.\n\t\t\tfor (let i = 0; i < batch.callbacks.length; i++) {\n\t\t\t\tconst value = values[i];\n\t\t\t\tif (value instanceof Error) {\n\t\t\t\t\tbatch.callbacks[i].reject(value);\n\t\t\t\t} else {\n\t\t\t\t\tbatch.callbacks[i].resolve(value);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t.catch((error: unknown) => {\n\t\t\tfailedDispatch(loader, batch, error as Error);\n\t\t});\n}\n\n// Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\nfunction failedDispatch<K, V>(loader: DataLoader<K, V, any>, batch: Batch<K, V>, error: Error) {\n\t// Cache hits are resolved, even though the batch failed.\n\tresolveCacheHits(batch);\n\tfor (let i = 0; i < batch.keys.length; i++) {\n\t\tloader.clear(batch.keys[i]);\n\t\tbatch.callbacks[i].reject(error);\n\t}\n}\n\n// Private: Resolves the Promises for any cache hits in this batch.\nfunction resolveCacheHits(batch: Batch<any, any>) {\n\tif (batch.cacheHits) {\n\t\tfor (let i = 0; i < batch.cacheHits.length; i++) {\n\t\t\tbatch.cacheHits[i]();\n\t\t}\n\t}\n}\n\n// Private: given the DataLoader's options, produce a valid max batch size.\nfunction getValidMaxBatchSize<K, V, C>(options?: DataLoader.Options<K, V, C>): number {\n\tconst shouldBatch = !options || options.batch !== false;\n\tif (!shouldBatch) {\n\t\treturn 1;\n\t}\n\tconst maxBatchSize = options && options.maxBatchSize;\n\tif (maxBatchSize === undefined) {\n\t\treturn Infinity;\n\t}\n\tif (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n\t\tthrow new TypeError(`maxBatchSize must be a positive number: ${maxBatchSize}`);\n\t}\n\treturn maxBatchSize;\n}\n\n// Private\nfunction getValidBatchScheduleFn<K, V, C>(\n\toptions?: DataLoader.Options<K, V, C>,\n): (cb: () => void) => void {\n\tconst batchScheduleFn = options && options.batchScheduleFn;\n\tif (batchScheduleFn === undefined) {\n\t\treturn enqueuePostPromiseJob;\n\t}\n\tif (typeof batchScheduleFn !== 'function') {\n\t\tthrow new TypeError(`batchScheduleFn must be a function: ${batchScheduleFn}`);\n\t}\n\treturn batchScheduleFn;\n}\n\n// Private: given the DataLoader's options, produce a cache key function.\nfunction getValidCacheKeyFn<K, V, C>(options?: DataLoader.Options<K, V, C>): (key: K) => C {\n\tconst cacheKeyFn = options && options.cacheKeyFn;\n\tif (cacheKeyFn === undefined) {\n\t\treturn (key: K) => key as unknown as C;\n\t}\n\tif (typeof cacheKeyFn !== 'function') {\n\t\tthrow new TypeError(`cacheKeyFn must be a function: ${cacheKeyFn}`);\n\t}\n\treturn cacheKeyFn;\n}\n\n// Private: given the DataLoader's options, produce a CacheMap to be used.\nfunction getValidCacheMap<K, V, C>(\n\toptions?: DataLoader.Options<K, V, C>,\n): DataLoader.CacheMap<C, Promise<V>> | null {\n\tconst shouldCache = !options || options.cache !== false;\n\tif (!shouldCache) {\n\t\treturn null;\n\t}\n\tconst cacheMap = options && options.cacheMap;\n\tif (cacheMap === undefined) {\n\t\treturn new Map();\n\t}\n\tif (cacheMap !== null) {\n\t\tconst cacheFunctions = ['get', 'set', 'delete', 'clear'] as const;\n\t\tconst missingFunctions = cacheFunctions.filter(\n\t\t\t(fnName) => cacheMap && typeof cacheMap[fnName] !== 'function',\n\t\t);\n\t\tif (missingFunctions.length !== 0) {\n\t\t\tthrow new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n\t\t}\n\t}\n\treturn cacheMap;\n}\n\nfunction getValidName<K, V, C>(options?: DataLoader.Options<K, V, C>): string | null {\n\tif (options && options.name) {\n\t\treturn options.name;\n\t}\n\n\treturn null;\n}\n\nfunction isArrayLike(x: unknown): x is ArrayLike<unknown> {\n\treturn (\n\t\ttypeof x === 'object' &&\n\t\tx !== null &&\n\t\t'length' in x &&\n\t\ttypeof x.length === 'number' &&\n\t\t(x.length === 0 || (x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1)))\n\t);\n}\n\nexport declare namespace DataLoader {\n\t// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\texport type CacheMap<K, V> = {\n\t\tget(key: K): V | void;\n\t\tset(key: K, value: V): any;\n\t\tdelete(key: K): any;\n\t\tclear(): any;\n\t};\n\n\t// A Function, which when given an Array of keys, returns a Promise of an Array\n\t// of values or Errors.\n\texport type BatchLoadFn<K, V> = (keys: ReadonlyArray<K>) => PromiseLike<ArrayLike<V | Error>>;\n\n\t// Optionally turn off batching or caching or provide a cache key function or a\n\t// custom cache instance.\n\texport type Options<K, V, C = K> = {\n\t\t/**\n\t\t * Default `true`. Set to `false` to disable batching, invoking\n\t\t * `batchLoadFn` with a single load key. This is equivalent to setting\n\t\t * `maxBatchSize` to `1`.\n\t\t */\n\t\tbatch?: boolean;\n\n\t\t/**\n\t\t * Default `Infinity`. Limits the number of items that get passed in to the\n\t\t * `batchLoadFn`. May be set to `1` to disable batching.\n\t\t */\n\t\tmaxBatchSize?: number;\n\n\t\t/**\n\t\t * Default see https://github.com/graphql/dataloader#batch-scheduling.\n\t\t * A function to schedule the later execution of a batch. The function is\n\t\t * expected to call the provided callback in the immediate future.\n\t\t */\n\t\tbatchScheduleFn?: (callback: () => void) => void;\n\n\t\t/**\n\t\t * Default `true`. Set to `false` to disable memoization caching, creating a\n\t\t * new Promise and new key in the `batchLoadFn` for every load of the same\n\t\t * key. This is equivalent to setting `cacheMap` to `null`.\n\t\t */\n\t\tcache?: boolean;\n\n\t\t/**\n\t\t * Default `key => key`. Produces cache key for a given load key. Useful\n\t\t * when keys are objects and two objects should be considered equivalent.\n\t\t */\n\t\tcacheKeyFn?: (key: K) => C;\n\n\t\t/**\n\t\t * Default `new Map()`. Instance of `Map` (or an object with a similar API)\n\t\t * to be used as cache. May be set to `null` to disable caching.\n\t\t */\n\t\tcacheMap?: CacheMap<C, Promise<V>> | null;\n\n\t\t/**\n\t\t * The name given to this `DataLoader` instance. Useful for APM tools.\n\t\t *\n\t\t * Is `null` if not set in the constructor.\n\t\t */\n\t\tname?: string | null;\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}