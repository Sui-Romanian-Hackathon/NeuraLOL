{"ast":null,"code":"import { BcsEnum, BcsStruct, BcsTuple, BcsType, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, lazyBcsType, stringLikeBcsType, uIntBcsType } from \"./bcs-type.js\";\nimport { ulebEncode } from \"./uleb.js\";\nfunction fixedArray(size, type, options) {\n  return new BcsType({\n    read: reader => {\n      const result = new Array(size);\n      for (let i = 0; i < size; i++) {\n        result[i] = type.read(reader);\n      }\n      return result;\n    },\n    write: (value, writer) => {\n      for (const item of value) {\n        type.write(item, writer);\n      }\n    },\n    ...options,\n    name: options?.name ?? `${type.name}[${size}]`,\n    validate: value => {\n      options?.validate?.(value);\n      if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n        throw new TypeError(`Expected array, found ${typeof value}`);\n      }\n      if (value.length !== size) {\n        throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n      }\n    }\n  });\n}\nfunction option(type) {\n  return bcs.enum(`Option<${type.name}>`, {\n    None: null,\n    Some: type\n  }).transform({\n    input: value => {\n      if (value == null) {\n        return {\n          None: true\n        };\n      }\n      return {\n        Some: value\n      };\n    },\n    output: value => {\n      if (value.$kind === \"Some\") {\n        return value.Some;\n      }\n      return null;\n    }\n  });\n}\nfunction vector(type, options) {\n  return new BcsType({\n    read: reader => {\n      const length = reader.readULEB();\n      const result = new Array(length);\n      for (let i = 0; i < length; i++) {\n        result[i] = type.read(reader);\n      }\n      return result;\n    },\n    write: (value, writer) => {\n      writer.writeULEB(value.length);\n      for (const item of value) {\n        type.write(item, writer);\n      }\n    },\n    ...options,\n    name: options?.name ?? `vector<${type.name}>`,\n    validate: value => {\n      options?.validate?.(value);\n      if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n        throw new TypeError(`Expected array, found ${typeof value}`);\n      }\n    }\n  });\n}\nfunction map(keyType, valueType) {\n  return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n    name: `Map<${keyType.name}, ${valueType.name}>`,\n    input: value => {\n      return [...value.entries()];\n    },\n    output: value => {\n      const result = /* @__PURE__ */new Map();\n      for (const [key, val] of value) {\n        result.set(key, val);\n      }\n      return result;\n    }\n  });\n}\nconst bcs = {\n  /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */\n  u8(options) {\n    return uIntBcsType({\n      readMethod: \"read8\",\n      writeMethod: \"write8\",\n      size: 1,\n      maxValue: 2 ** 8 - 1,\n      ...options,\n      name: options?.name ?? \"u8\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */\n  u16(options) {\n    return uIntBcsType({\n      readMethod: \"read16\",\n      writeMethod: \"write16\",\n      size: 2,\n      maxValue: 2 ** 16 - 1,\n      ...options,\n      name: options?.name ?? \"u16\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */\n  u32(options) {\n    return uIntBcsType({\n      readMethod: \"read32\",\n      writeMethod: \"write32\",\n      size: 4,\n      maxValue: 2 ** 32 - 1,\n      ...options,\n      name: options?.name ?? \"u32\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */\n  u64(options) {\n    return bigUIntBcsType({\n      readMethod: \"read64\",\n      writeMethod: \"write64\",\n      size: 8,\n      maxValue: 2n ** 64n - 1n,\n      ...options,\n      name: options?.name ?? \"u64\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u128(options) {\n    return bigUIntBcsType({\n      readMethod: \"read128\",\n      writeMethod: \"write128\",\n      size: 16,\n      maxValue: 2n ** 128n - 1n,\n      ...options,\n      name: options?.name ?? \"u128\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u256(options) {\n    return bigUIntBcsType({\n      readMethod: \"read256\",\n      writeMethod: \"write256\",\n      size: 32,\n      maxValue: 2n ** 256n - 1n,\n      ...options,\n      name: options?.name ?? \"u256\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */\n  bool(options) {\n    return fixedSizeBcsType({\n      size: 1,\n      read: reader => reader.read8() === 1,\n      write: (value, writer) => writer.write8(value ? 1 : 0),\n      ...options,\n      name: options?.name ?? \"bool\",\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"boolean\") {\n          throw new TypeError(`Expected boolean, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */\n  uleb128(options) {\n    return dynamicSizeBcsType({\n      read: reader => reader.readULEB(),\n      serialize: value => {\n        return Uint8Array.from(ulebEncode(value));\n      },\n      ...options,\n      name: options?.name ?? \"uleb128\"\n    });\n  },\n  /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */\n  bytes(size, options) {\n    return fixedSizeBcsType({\n      size,\n      read: reader => reader.readBytes(size),\n      write: (value, writer) => {\n        writer.writeBytes(new Uint8Array(value));\n      },\n      ...options,\n      name: options?.name ?? `bytes[${size}]`,\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length byte array\n   *\n   * @example\n   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n   */\n  byteVector(options) {\n    return new BcsType({\n      read: reader => {\n        const length = reader.readULEB();\n        return reader.readBytes(length);\n      },\n      write: (value, writer) => {\n        const array = new Uint8Array(value);\n        writer.writeULEB(array.length);\n        writer.writeBytes(array);\n      },\n      ...options,\n      name: options?.name ?? \"vector<u8>\",\n      serializedSize: value => {\n        const length = \"length\" in value ? value.length : null;\n        return length == null ? null : ulebEncode(length).length + length;\n      },\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */\n  string(options) {\n    return stringLikeBcsType({\n      toBytes: value => new TextEncoder().encode(value),\n      fromBytes: bytes => new TextDecoder().decode(bytes),\n      ...options,\n      name: options?.name ?? \"string\"\n    });\n  },\n  /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */\n  fixedArray,\n  /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */\n  option,\n  /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */\n  vector,\n  /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */\n  tuple(fields, options) {\n    return new BcsTuple({\n      fields,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */\n  struct(name, fields, options) {\n    return new BcsStruct({\n      name,\n      fields,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */\n  enum(name, fields, options) {\n    return new BcsEnum({\n      name,\n      fields,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */\n  map,\n  /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */\n  lazy(cb) {\n    return lazyBcsType(cb);\n  }\n};\nexport { bcs };","map":{"version":3,"names":["BcsEnum","BcsStruct","BcsTuple","BcsType","bigUIntBcsType","dynamicSizeBcsType","fixedSizeBcsType","lazyBcsType","stringLikeBcsType","uIntBcsType","ulebEncode","fixedArray","size","type","options","read","reader","result","Array","i","write","value","writer","item","name","validate","TypeError","length","option","bcs","enum","None","Some","transform","input","output","$kind","vector","readULEB","writeULEB","map","keyType","valueType","tuple","entries","Map","key","val","set","u8","readMethod","writeMethod","maxValue","u16","u32","u64","u128","u256","bool","read8","write8","uleb128","serialize","Uint8Array","from","bytes","readBytes","writeBytes","byteVector","array","serializedSize","string","toBytes","TextEncoder","encode","fromBytes","TextDecoder","decode","fields","struct","lazy","cb"],"sources":["/Users/joitafabian/Documents/Hackathon/my-trash-app/node_modules/@mysten/bcs/src/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsEnum,\n\tBcsStruct,\n\tBcsTuple,\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type {\n\tEnumInputShape,\n\tEnumOutputShape,\n\tInferBcsInput,\n\tInferBcsType,\n\tJoinString,\n} from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nfunction fixedArray<T extends BcsType<any>, Name extends string = string>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction fixedArray<T, Input, Name extends string = string>(\n\tsize: number,\n\ttype: BcsType<T, Input>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, Name>,\n): BcsType<T[], Iterable<Input> & { length: number }, Name>;\nfunction fixedArray<T extends BcsType<any>, Name extends string = `${T['name']}[${number}]`>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst result: InferBcsType<T>[] = new Array(size);\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `${type.name}[${size}]`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t\tif (value.length !== size) {\n\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`>;\nfunction option<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n): BcsType<T | null, Input | null | undefined>;\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`> {\n\treturn bcs\n\t\t.enum(`Option<${type.name}>`, {\n\t\t\tNone: null,\n\t\t\tSome: type,\n\t\t})\n\t\t.transform({\n\t\t\tinput: (value: InferBcsInput<T> | null | undefined) => {\n\t\t\t\tif (value == null) {\n\t\t\t\t\treturn { None: true };\n\t\t\t\t}\n\n\t\t\t\treturn { Some: value };\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\treturn value.Some as InferBcsType<T>;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t},\n\t\t});\n}\n\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction vector<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>,\n): BcsType<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>;\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst result: InferBcsType<T>[] = new Array(length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\twriter.writeULEB(value.length);\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `vector<${type.name}>`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n>;\nfunction map<K, V, InputK = K, InputV = V>(\n\tkeyType: BcsType<K, InputK>,\n\tvalueType: BcsType<V, InputV>,\n): BcsType<Map<K, V>, Map<InputK, InputV>, `Map<${string}, ${string}>`>;\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n> {\n\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\tinput: (value: Map<InferBcsInput<K>, InferBcsInput<V>>) => {\n\t\t\treturn [...value.entries()];\n\t\t},\n\t\toutput: (value) => {\n\t\t\tconst result = new Map<InferBcsType<K>, InferBcsType<V>>();\n\t\t\tfor (const [key, val] of value) {\n\t\t\t\tresult.set(key, val);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t});\n}\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u8') as 'u8',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u16') as 'u16',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u32') as 'u32',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u64') as 'u64',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u128') as 'u128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u256') as 'u256',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType({\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'bool') as 'bool',\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType({\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'uleb128') as 'uleb128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>, `bytes[${T}]`>({\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeBytes(new Uint8Array(value));\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? `bytes[${size}]`) as `bytes[${T}]`,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>, 'vector<u8>'>({\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\twriter.writeBytes(array);\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'vector<u8>') as 'vector<u8>',\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'string') as 'string',\n\t\t});\n\t},\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray,\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption,\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector,\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<\n\t\tconst T extends readonly BcsType<any, any>[],\n\t\tconst Name extends\n\t\t\tstring = `(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n\t>(\n\t\tfields: T,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t) {\n\t\treturn new BcsTuple<T, Name>({\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsStruct<T>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t\t}>,\n\t\t\t\tName\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsEnum<T, Name>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap,\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}